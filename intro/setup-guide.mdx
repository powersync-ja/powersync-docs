---
title: "PowerSync Setup Guide"
sidebarTitle: "Setup Guide"
description: "This guide walks you through adding PowerSync to your app project step-by-step. "
---

import LocalOnly from '/snippets/local-only-escape.mdx';
import ReactNativeInstallation from '/snippets/react-native/installation.mdx';
import JavaScriptWebInstallation from '/snippets/javascript-web/installation.mdx';
import NodeInstallation from '/snippets/node/installation.mdx';
import CapacitorInstallation from '/snippets/capacitor/installation.mdx';
import FlutterInstallation from '/snippets/flutter/installation.mdx';
import KotlinInstallation from '/snippets/kotlin/installation.mdx';
import SwiftInstallation from '/snippets/swift/installation.mdx';
import DotnetInstallation from '/snippets/dotnet/installation.mdx';
import RustInstallation from '/snippets/rust/installation.mdx';
import DevTokenSelfHostedSteps from '/snippets/dev-token-self-hosted-steps.mdx';

# 1. Configure Your Source Database

PowerSync needs to connect to your source database (Postgres, MongoDB, MySQL or SQL Server) to replicate data. Before setting up PowerSync, you need to configure your database with the appropriate permissions and replication settings.

<Tip>
Using the CLI and want a managed self-hosted Postgres instance? You can skip to [Step 2](#2-set-up-powersync-service-instance) and set one up automatically.
</Tip>

<Tabs>
      <Tab title="Postgres">
        Configuring Postgres for PowerSync involves three main tasks:

        1. **Enable logical replication**: PowerSync reads the Postgres WAL using logical replication. Set `wal_level = logical` in your Postgres configuration.
        2. **Create a PowerSync database user**: Create a role with replication privileges and read-only access to your tables.
        3. **Create a `powersync` publication**: Create a logical replication publication named `powersync` to specify which tables to replicate.

        <CodeGroup>
          ```sql General
          -- 1. Enable logical replication (requires restart)
          ALTER SYSTEM SET wal_level = logical;
          
          -- 2. Create PowerSync database user/role with replication privileges and read-only access to your tables
          CREATE ROLE powersync_role WITH REPLICATION BYPASSRLS LOGIN PASSWORD 'myhighlyrandompassword';
          
          -- Set up permissions for the newly created role
          -- Read-only (SELECT) access is required
          GRANT SELECT ON ALL TABLES IN SCHEMA public TO powersync_role;
          
          -- Optionally, grant SELECT on all future tables (to cater for schema additions)
          ALTER DEFAULT PRIVILEGES IN SCHEMA public GRANT SELECT ON TABLES TO powersync_role;
          
          -- 3. Create a publication to replicate tables. The publication must be named "powersync"
          CREATE PUBLICATION powersync FOR ALL TABLES;
          ```

          ```sql Supabase
          -- Supabase has logical replication enabled by default
          -- Just create the user and publication:
          
          -- Create PowerSync database user/role with replication privileges and read-only access to your tables
          CREATE ROLE powersync_role WITH REPLICATION BYPASSRLS LOGIN PASSWORD 'myhighlyrandompassword';
          
          -- Set up permissions for the newly created role
          -- Read-only (SELECT) access is required
          GRANT SELECT ON ALL TABLES IN SCHEMA public TO powersync_role;
          
          -- Optionally, grant SELECT on all future tables (to cater for schema additions)
          ALTER DEFAULT PRIVILEGES IN SCHEMA public GRANT SELECT ON TABLES TO powersync_role;
          
          -- Create a publication to replicate tables. The publication must be named "powersync"
          CREATE PUBLICATION powersync FOR ALL TABLES;
          ```

          ```bash Docker (Self-hosting)
          # 1. Create a Docker network (if not already created)
          # This allows various PowerSync containers to communicate with each other
          docker network create powersync-network

          # 2. Run Postgres source database with logical replication enabled (required for PowerSync)
          docker run -d \
            --name powersync-postgres \
            --network powersync-network \
            -e POSTGRES_PASSWORD="my_secure_password" \
            -p 5432:5432 \
            postgres:18 \
            postgres -c wal_level=logical

          # 3. Configure PowerSync user and publication
          # This creates a PowerSync database user/role with replication privileges and read-only access to your tables
          # Read-only (SELECT) access is also granted to all future tables (to cater for schema additions)
          # It also creates a publication to replicate tables. The publication must be named "powersync"
          docker exec -it powersync-postgres psql -U postgres -c "
          CREATE ROLE powersync_role WITH REPLICATION BYPASSRLS LOGIN PASSWORD 'myhighlyrandompassword';
          GRANT SELECT ON ALL TABLES IN SCHEMA public TO powersync_role;
          ALTER DEFAULT PRIVILEGES IN SCHEMA public GRANT SELECT ON TABLES TO powersync_role;
          CREATE PUBLICATION powersync FOR ALL TABLES;"
          ```
        </CodeGroup>

        <Note>
          * **Version compatibility**: PowerSync requires Postgres version 11 or greater.
        </Note>

        <Tip>
          **Learn More**
          
          * For more details on Postgres setup, including provider-specific guides (Supabase, AWS RDS, etc.), see [Source Database Setup](/configuration/source-db/setup#postgres).
          * **Self-hosting PowerSync?** See the [Self-Host-Demo App](https://github.com/powersync-ja/self-host-demo/tree/main/demos/nodejs) for a complete working example of connecting a Postgres source database to PowerSync.
        </Tip>
      </Tab>

      <Tab title="MongoDB Atlas">
        For MongoDB Atlas databases, the minimum permissions when using built-in roles are:

        ```
        read@<your_database>
        readWrite@<your_database>._powersync_checkpoints
        ```

        To allow PowerSync to automatically enable `changeStreamPreAndPostImages` on replicated collections (optional, but recommended), additionally add:

        ```
        dbAdmin@<your_database>
        ```

        <Note>
          **Version compatibility**: PowerSync requires MongoDB version 6.0 or greater.
        </Note>
        <Tip>
          **Learn More**
          
          * For more details including instructions for self-hosted MongoDB, or for custom roles on MongoDB Atlas, see [Source Database Setup](/configuration/source-db/setup#mongodb).
          * **Self-hosting PowerSync?** See the [Self-Host-Demo App](https://github.com/powersync-ja/self-host-demo/tree/main/demos/nodejs-mongodb) for a complete working example of connecting a MongoDB source database to PowerSync.
        </Tip>
      </Tab>

      <Tab title="MySQL (beta)">
        For MySQL, you need to configure binary logging and create a user with replication privileges:

        ```sql
          -- Configure binary logging
          -- Add to MySQL option file (my.cnf or my.ini):
          server_id=<Unique Integer Value>
          log_bin=ON
          enforce_gtid_consistency=ON
          gtid_mode=ON
          binlog_format=ROW

          -- Create a user with necessary privileges
          CREATE USER 'repl_user'@'%' IDENTIFIED BY '<password>';

          -- Grant replication client privilege
          GRANT REPLICATION SLAVE, REPLICATION CLIENT ON *.* TO 'repl_user'@'%';

          -- Grant select access to the specific database
          GRANT SELECT ON <source_database>.* TO 'repl_user'@'%';

          -- Apply changes
          FLUSH PRIVILEGES;
        ```

        <Note>
          **Version compatibility**: PowerSync requires MySQL version 5.7 or greater.
        </Note>
        <Tip>
          **Learn More**
          
          * For more details on MySQL setup, see [Source Database Setup](/configuration/source-db/setup#mysql-beta).
          * **Self-hosting PowerSync?** See the [Self-Host-Demo App](https://github.com/powersync-ja/self-host-demo/tree/main/demos/nodejs-mysql) for a complete working example of connecting a MySQL source database to PowerSync.
        </Tip>
      </Tab>

      <Tab title="SQL Server (alpha)">
        Refer to [these instructions](/configuration/source-db/setup#sql-server-alpha).

        **Self-hosting PowerSync?** See the [Self-Host-Demo App](https://github.com/powersync-ja/self-host-demo/tree/main/demos/nodejs-mssql) for a complete working example of connecting a SQL Server source database to PowerSync.
      </Tab>
    </Tabs>

# 2. Set Up PowerSync Service Instance

PowerSync is available as a cloud-hosted service (PowerSync Cloud) or can be self-hosted (PowerSync Open Edition or PowerSync Enterprise Self-Hosted Edition).

<Tabs>
  <Tab title="Dashboard (Cloud)">
    If you haven't yet, sign up for a free PowerSync Cloud account [here](https://accounts.journeyapps.com/portal/powersync-signup?s=docs).

    After signing up, you will be taken to the [PowerSync Dashboard](https://dashboard.powersync.com/).

    Here, create a new project. _Development_ and _Production_ instances of the PowerSync Service will be created by default in the project.
  </Tab>

  <Tab title="CLI (Cloud)">
    If you haven't yet, sign up for a free PowerSync Cloud account [here](https://accounts.journeyapps.com/portal/powersync-signup?s=docs).

    Install the [PowerSync CLI](/tools/cli) (requires Node.js/npm), then log in and scaffold the config directory:

    ```bash
    npm install -g powersync
    powersync login
    powersync init cloud
    ```

    This creates a `powersync/` directory with `service.yaml` (instance name, region, connection, auth) and `sync-config.yaml` (sync config). Edit `powersync/service.yaml` to set your instance name and region — you'll configure the database connection in the next step.

    Then create the Cloud instance:

    ```bash
    powersync link cloud --create --project-id=<project-id>
    ```

    Find your project ID in the [PowerSync Dashboard](https://dashboard.powersync.com) URL, or run `powersync fetch instances` after logging in.
  </Tab>

  <Tab title="CLI (Self-Hosted)">
    Recommended for getting started. For custom setups use the **Manual (Self-Hosted)** tab. Install the [PowerSync CLI](/tools/cli) (requires Node.js/npm), scaffold the config directory, and generate the Docker Compose setup:

    ```bash
    npm install -g powersync
    powersync init self-hosted
    powersync docker configure --database postgres --storage postgres
    ```

    Docker sets up Postgres for both the source database and bucket storage and creates `powersync/docker/docker-compose.yaml`. Other databases are supported as well, you will learn more about this in the next step. Before starting, replace `powersync/sync-config.yaml` with this minimal sync config:

    ```yaml
    config:
      edition: 2

    streams:
      todos:
        # Streams without parameters sync the same data to all users
        auto_subscribe: true
        query: "SELECT * FROM todos"
    ```

    You'll update this with your actual tables/collections in a later step.

    Then start the PowerSync Service:

    ```bash
    powersync docker start
    ```

    Run `powersync fetch status` to verify it's running.

    <Tip>
      **Learn More**
      * [Self-Hosting Introduction](/intro/self-hosting)
      * [Self-Host Demo App](https://github.com/powersync-ja/self-host-demo) for complete working examples.
      * [Self-Hosted Service Configuration](/configuration/powersync-service/self-hosted-instances) for more details on the config file structure.
      * [CLI documentation](/tools/cli)
    </Tip>
  </Tab>

  <Tab title="Manual (Self-Hosted)">
    Self-hosted PowerSync runs via Docker. The commands below illustrate the basic PowerSync Service requirements.

    Below is a minimal example using Postgres for bucket storage. MongoDB is also supported as bucket storage. The source database connection is configured in the next step — you can use the Docker-managed Postgres from Step 1 or point to an external database instead.

    ```bash
    # 1. Create a directory for your config
    mkdir powersync-service && cd powersync-service

    # 2. Set up bucket storage (Postgres and MongoDB are supported)
    docker run -d \
      --name powersync-postgres-storage \
      --network powersync-network \
      -p 5433:5432 \
      -e POSTGRES_PASSWORD="my_secure_storage_password" \
      -e POSTGRES_DB=powersync_storage \
      postgres:18

    ## Set up Postgres storage user
    docker exec -it powersync-postgres-storage psql -U postgres -d powersync_storage -c "
    CREATE USER powersync_storage_user WITH PASSWORD 'my_secure_user_password';
    GRANT CREATE ON DATABASE powersync_storage TO powersync_storage_user;"

    # 3. Create config.yaml (see below)

    # 4. Run PowerSync Service
    # The Service config can be specified as an environment variable (shown below), as a filepath, or as a command line parameter
    # See these docs for more details: https://docs.powersync.com/configuration/powersync-service/self-hosted-instances
    docker run -d \
      --name powersync \
      --network powersync-network \
      -p 8080:8080 \
      -e POWERSYNC_CONFIG_B64="$(base64 -i ./config.yaml)" \
      journeyapps/powersync-service:latest
    ```

    **Basic `config.yaml` structure:**

    ```yaml
    # Source database connection (see the next step for more details)
    replication:
      connections:
        - type: postgresql # or mongodb, mysql, mssql
          uri: postgresql://powersync_role:myhighlyrandompassword@powersync-postgres:5432/postgres
          sslmode: disable  # Only for local/private networks

    # Connection settings for bucket storage (Postgres and MongoDB are supported)
    storage:
      type: postgresql
      uri: postgresql://powersync_storage_user:my_secure_user_password@powersync-postgres-storage:5432/powersync_storage
      sslmode: disable  # Use 'disable' only for local/private networks

    # Sync Rules (defined in a later step)
    sync_rules:
      content: |
        bucket_definitions:
          global:
            data:
              - SELECT * FROM lists
              - SELECT * FROM todos
    ```

    <Warning>
      **Note**: This example assumes you've configured your source database with the required user and publication (see the previous step)
      and are running it via Docker in the 'powersync-network' network.

      If you are not using Docker, you will need to specify the connection details in the `config.yaml` file manually (see next step for more details).
    </Warning>

    <Tip>
      **Learn More**
      * [Self-Hosting Introduction](/intro/self-hosting)
      * [Self-Host Demo App](https://github.com/powersync-ja/self-host-demo) for complete working examples.
      * [Self-Hosted Service Configuration](/configuration/powersync-service/self-hosted-instances) for more details on the config file structure.
      * [CLI documentation](/tools/cli)
    </Tip>

  </Tab>
</Tabs>

# 3. Connect PowerSync to Your Source Database

The next step is to connect your PowerSync Service instance to your source database.

<Tabs>
  <Tab title="Dashboard (Cloud)">
    In the [PowerSync Dashboard](https://dashboard.powersync.com/), select your project and instance, then go to **Database Connections**:

    1. Click **Connect to Source Database**
    2. Select the appropriate database type tab (Postgres, MongoDB, MySQL or SQL Server)
    3. Fill in your connection details:
        <Note>
          **Note**: Use the username (e.g., `powersync_role`) and password you created in Step 1: Configure your Source Database.
        </Note>
       - **Postgres**: Host, Port (5432), Database name, Username, Password, SSL Mode
       - **MongoDB**: Connection URI (e.g., `mongodb+srv://user:pass@cluster.mongodb.net/database`)
       - **MySQL**: Host, Port (3306), Database name, Username, Password
       - **SQL Server**: Name, Host, Port (1433), Database name, Username, Password
    4. Click **Test Connection** to verify
    5. Click **Save Connection**

    PowerSync will now deploy and configure an isolated cloud environment, which can take a few minutes.

    <Tip>
      **Learn More**

      For more details on database connections, including provider-specific connection details (Supabase, AWS RDS, MongoDB Atlas, etc.), see [Source Database Connection](/configuration/source-db/connection).
    </Tip>
  </Tab>

  <Tab title="CLI (Cloud)">
    Edit `powersync/service.yaml` (created in the previous step) with your connection details. Use `!env` for secrets:

    <Note>
      **Note**: Use the username (e.g., `powersync_role`) and password you created in Step 1: Configure your Source Database.
    </Note>

    <CodeGroup>
      ```yaml Postgres
      replication:
        connections:
          - type: postgresql
            uri: postgresql://powersync_role:myhighlyrandompassword@host:5432/postgres
            sslmode: disable # 'verify-full' (default) or 'verify-ca' or 'disable'
            # Note: 'disable' is only suitable for local/private networks
      ```

      ```yaml MongoDB
      replication:
        connections:
          - type: mongodb
            uri: mongodb+srv://user:password@cluster.mongodb.net/database
            post_images: auto_configure
      ```

      ```yaml MySQL
      replication:
        connections:
          - type: mysql
            uri: mysql://repl_user:password@host:3306/database
      ```

      ```yaml SQL Server
      replication:
        connections:
          - type: mssql
            uri: mssql://user:password@host:1433/database
            schema: dbo
      ```
    </CodeGroup>

    You will run `powersync deploy` in a later step to deploy your config to the PowerSync Cloud instance.

    <Tip>
      **Learn More**

      For more details on database connections, including provider-specific connection details (Supabase, AWS RDS, MongoDB Atlas, etc.), see [Source Database Connection](/configuration/source-db/connection).
    </Tip>
  </Tab>

  <Tab title="CLI (Self-Hosted)">
    If you used Docker in the previous step, the source database connection is already configured. `service.yaml` reads the connection URI from `!env PS_DATA_SOURCE_URI`. The Docker-managed Postgres (`pg-db`) was also pre-configured with `wal_level=logical` and a `powersync` publication by the init scripts.

    If you want to use an **external database** instead, update `PS_DATA_SOURCE_URI` in `powersync/docker/.env` with your connection details, then restart:

    ```bash
    powersync docker reset
    ```

    You'll also need to complete the source database setup from Step 1 (replication user, publication) on your external database before this will work.
  </Tab>

  <Tab title="Manual (Self-Hosted)">
    Configure the source database connection in your `config.yaml` file (as you did in the previous step). Examples for the different database types are below.

    <Note>
      **Note**: Use the username (e.g., `powersync_role`) and password you created in Step 1: Configure your Source Database.
    </Note>

    <CodeGroup>
      ```yaml Postgres
      replication:
        connections:
          - type: postgresql
            uri: postgresql://powersync_role:myhighlyrandompassword@powersync-postgres:5432/postgres
            sslmode: disable # 'verify-full' (default) or 'verify-ca' or 'disable'
            # Note: 'disable' is only suitable for local/private networks, not for public networks
      ```

      ```yaml MongoDB
      replication:
        connections:
          - type: mongodb
            uri: mongodb+srv://user:password@cluster.mongodb.net/database
            post_images: auto_configure
      ```

      ```yaml MySQL
      replication:
        connections:
          - type: mysql
            uri: mysql://repl_user:password@host:3306/database
      ```

      ```yaml SQL Server
      replication:
        connections:
          - type: mssql
            uri: mssql://user:password@$host:1433/database
            schema: dbo
            additionalConfig:
              trustServerCertificate: true
              pollingIntervalMs: 1000
              pollingBatchSize: 20
      ```
    </CodeGroup>

    <Tip>
      **Learn More**

      See the [self-host-demo app](https://github.com/powersync-ja/self-host-demo) for complete working examples of the different database types.
    </Tip>
  </Tab>
</Tabs>


# 4. Define Basic Sync Rules

Sync Rules control which data gets synced to which users/devices. They consist of SQL-like queries organized into "buckets" (groupings of data). Each PowerSync Service instance has a Sync Rules definition in YAML format.

We recommend starting with a simple **global bucket** that syncs data to all users. This is the simplest way to get started.

<CodeGroup>
      ```yaml Postgres Example
      bucket_definitions:
        global:
          data:
            - SELECT * FROM todos
            - SELECT * FROM lists WHERE archived = false
      ```

      ```yaml MongoDB Example
      bucket_definitions:
        global:
          data:
            # Note that MongoDB uses “_id” as the name of the ID field in collections whereas
            # PowerSync uses “id” in its client-side database. This is why the below syntax
            # should always be used in the data queries when pairing PowerSync with MongoDB.
            - SELECT _id as id, * FROM lists
            - SELECT _id as id, * FROM todos WHERE archived = false
      ```

      ```yaml MySQL Example
      bucket_definitions:
        global:
          data:
            - SELECT * FROM todos
            - SELECT * FROM lists WHERE archived = 0
      ```

      ```yaml SQL Server Example
      bucket_definitions:
        global:
          data:
            - SELECT * FROM todos
            - SELECT * FROM lists WHERE archived = 0
      ```
    </CodeGroup>


### Deploy Sync Rules

<Tabs>
  <Tab title="Dashboard (Cloud)">
    In the [PowerSync Dashboard](https://dashboard.powersync.com/):

    1. Select your project and instance
    2. Go to the **Sync Rules** view
    3. Edit the YAML directly in the dashboard
    4. Click **Deploy** to validate and deploy your Sync Rules
  </Tab>

  <Tab title="CLI (Cloud)">
    Edit `powersync/sync-config.yaml` with your sync config, then validate and deploy to the linked Cloud instance:

    ```bash
    powersync validate
    powersync deploy
    ```

    This deploys your full config (connection, auth, and sync config). For subsequent sync-only changes, use `powersync deploy sync-config` instead.
  </Tab>

  <Tab title="CLI (Self-Hosted)">
    Edit `powersync/sync-config.yaml` with your sync config. The default file has a placeholder (`SELECT * FROM todos`) — replace it with your actual table/collection names. Then apply the changes:

    ```bash
    powersync validate
    powersync docker reset
    ```
  </Tab>

  <Tab title="Manual (Self-Hosted)">
    Add the sync rules to your `config.yaml`, for example:

    ```yaml
    sync_rules:
      content: |
        bucket_definitions:
          global:
            data:
              - SELECT * FROM todos
              - SELECT * FROM lists WHERE archived = false
    ```
  </Tab>
</Tabs>

<Note>
  **Note**: Table/collection names within your Sync Rules must match the table names defined in your client-side schema (defined in a later step below).
</Note>

<Tip>
  **Learn More**
  
  For more details on Sync Rules usage, see the [Sync Rules documentation](/sync/rules/overview).
</Tip>


# 5. Generate a Development Token

For quick development and testing, you can generate a temporary development token instead of implementing full authentication.

You'll use this token for two purposes:
- **Testing with the _Sync Diagnostics Client_** (in the next step) to verify your setup and Sync Rules
- **Connecting your app** (in a later step) to test the client SDK integration

<Tabs>
  <Tab title="Dashboard (Cloud)">
    1. In the [PowerSync Dashboard](https://dashboard.powersync.com/), select your project and instance
    2. Go to the **Client Auth** view
    3. Check the **Development tokens** setting and save your changes
    4. Click the **Connect** button in the top bar
    5. **Enter token subject**: Since you're starting with just a simple global bucket in your Sync Rules that syncs all data to all users (as we recommended in the previous step), you can just put something like `test-user` as the token subject (which would normally be the user ID you want to test with).
    6. Click **Generate token** and copy the token

    <Note>
      Development tokens expire after 12 hours.
    </Note>
  </Tab>

  <Tab title="CLI (Cloud)">
    Generate a development token with:

    ```bash
    powersync generate token --subject=test-user
    ```

    Replace `test-user` with a user ID of your choice (this would normally be the user ID you want to test with).

    Requires `allow_temporary_tokens` to be enabled on the instance. Add it to `powersync/service.yaml` if you haven't already, then redeploy:

    ```yaml
    client_auth:
      allow_temporary_tokens: true
    ```

    ```bash
    powersync deploy
    ```

    <Note>
      Development tokens expire after 12 hours.
    </Note>
  </Tab>

  <Tab title="Self-Hosted">
    Follow the steps below. Steps 1 and 2 configure signing keys and your PowerSync config; in Step 3 you can use the **CLI (recommended)** or the test-client to generate the token.

    <DevTokenSelfHostedSteps />
  </Tab>
</Tabs>

# 6. [Optional] Test Sync with the Sync Diagnostics Client

Before implementing the PowerSync Client SDK in your app, you can validate that syncing is working correctly using our [Sync Diagnostics Client](https://diagnostics-app.powersync.com) (this hosted version works with both PowerSync Cloud and self-hosted setups).

Use the development token you generated in the [previous step](#5-generate-a-development-token) to connect and verify your setup:

<Tabs>
  <Tab title="PowerSync Cloud">
    1. Go to [https://diagnostics-app.powersync.com](https://diagnostics-app.powersync.com)
    2. Enter your development token (from the [Generate a Development Token](#5-generate-a-development-token) step above)
    3. Enter your PowerSync instance URL (found in [PowerSync Dashboard](https://dashboard.powersync.com/) - click **Connect** in the top bar)
    4. Click **Connect**
  </Tab>

  <Tab title="Self-Hosted">
    1. Go to [https://diagnostics-app.powersync.com](https://diagnostics-app.powersync.com)
    2. Enter your development token (from the [Generate a Development Token](#5-generate-a-development-token) step above)
    3. Enter your PowerSync Service endpoint (the URL where your self-hosted service is running, e.g. `http://localhost:8080` if running locally)
    4. Click **Connect**

    <Note>
      The Sync Diagnostics Client can also be run as a local standalone web app — see the [README](https://github.com/powersync-ja/powersync-js/tree/main/tools/diagnostics-app#readme) for instructions.
    </Note>

  </Tab>
</Tabs>

The Sync Diagnostics Client will connect to your PowerSync Service instance and display [information](https://github.com/powersync-ja/powersync-js/tree/main/tools/diagnostics-app#functionality) about the synced data, and allow you to [query](https://github.com/powersync-ja/powersync-js/tree/main/tools/diagnostics-app#sql-console) the client-side SQLite database.

<Check>
  **Checkpoint:**

  Inspect your global bucket and synced tables in the Sync Diagnostics Client — these should match the Sync Rules you [defined previously](#4-define-basic-sync-rules). This confirms your setup is working correctly before integrating the client SDK into your app.
</Check>

# 7. Use the Client SDK

Now it's time to integrate PowerSync into your app. This involves installing the SDK, defining your client-side schema, instantiating the database, connecting to your PowerSync Service instance, and reading/writing data.

### Install the Client SDK

Add the PowerSync Client SDK to your app project. PowerSync provides SDKs for various platforms and frameworks.

<Tabs>
  <Tab title="React Native / Expo">
    <ReactNativeInstallation />
  </Tab>

  <Tab title="JavaScript Web">
    <JavaScriptWebInstallation />
  </Tab>

  <Tab title="Node.js">
    <NodeInstallation />
  </Tab>

  <Tab title="Capacitor">
    <CapacitorInstallation />
  </Tab>

  <Tab title="Dart/Flutter">
    <FlutterInstallation />
  </Tab>

  <Tab title="Kotlin">
    <KotlinInstallation />
  </Tab>

  <Tab title="Swift">
    <SwiftInstallation />
  </Tab>

  <Tab title=".NET">
    <DotnetInstallation />
  </Tab>

  <Tab title="Rust">
    <RustInstallation />
  </Tab>
</Tabs>

### Define Your Client-Side Schema

import SdkClientSideSchema from '/snippets/sdk-client-side-schema.mdx';

<SdkClientSideSchema />

_PowerSync Cloud:_ The easiest way to generate your schema is using the [PowerSync Dashboard](https://dashboard.powersync.com/). Click the **Connect** button in the top bar to generate the client-side schema based on your Sync Rules in your preferred language.

Here's an example schema for a simple `todos` table:

import SdkSchemaExamples from '/snippets/sdk-schema-examples.mdx';

<SdkSchemaExamples />

<Note>
  **Note**: The schema does not explicitly specify an `id` column, since PowerSync automatically creates an `id` column of type `text`. PowerSync [recommends](/sync/advanced/client-id) using UUIDs.
</Note>

<Tip>
  **Learn More**
  
  The client-side schema uses three column types: `text`, `integer`, and `real`. These map directly to values from your Sync Rules and are automatically cast if needed. For details on how backend database types map to SQLite types, see [Types](/sync/types).
</Tip>

### Instantiate the PowerSync Database

Now that you have your client-side schema defined, instantiate the PowerSync database in your app. This creates the client-side SQLite database that will be kept in sync with your source database based on your Sync Rules configuration.

import SdkInstantiateDbExamples from '/snippets/sdk-instantiate-db-examples.mdx';

<SdkInstantiateDbExamples />

### Connect to PowerSync Service Instance

Connect your client-side PowerSync database to the PowerSync Service instance you created in [step 2](#2-set-up-powersync-service-instance) by defining a _backend connector_ and calling `connect()`. The backend connector handles authentication and uploading mutations to your backend.

<LocalOnly />

<Note>You don't have to worry about the _backend connector_ implementation details right now — you can leave the boilerplate as-is and come back to it later.</Note>

For development, you can use the development token you generated in the [Generate a Development Token](#optional-generate-a-development-token) step above. For production, you'll implement proper JWT authentication as we'll explain further below.

<CodeGroup>
  ```typescript React Native (TS)
  import { AbstractPowerSyncDatabase, PowerSyncBackendConnector, PowerSyncCredentials } from '@powersync/react-native';
  import { db } from './Database';

  class Connector implements PowerSyncBackendConnector {
    async fetchCredentials(): Promise<PowerSyncCredentials> {
      // for development: use development token
      return {
        endpoint: 'https://your-instance.powersync.com',
        token: 'your-development-token-here'
      };
    }

    async uploadData(database: AbstractPowerSyncDatabase) {
      const transaction = await database.getNextCrudTransaction();
      if (!transaction) return;

      for (const op of transaction.crud) {
        const record = { ...op.opData, id: op.id };
        // upload to your backend API
      }

      await transaction.complete();
    }
  }

  // connect the database to PowerSync Service
  const connector = new Connector();
  await db.connect(connector);
  ```

  ```typescript Web & Capacitor (TS)
  import { AbstractPowerSyncDatabase, PowerSyncBackendConnector, PowerSyncCredentials } from '@powersync/web';
  import { db } from './Database';

  class Connector implements PowerSyncBackendConnector {
    async fetchCredentials(): Promise<PowerSyncCredentials> {
      // for development: use development token
      return {
        endpoint: 'https://your-instance.powersync.com',
        token: 'your-development-token-here'
      };
    }

    async uploadData(database: AbstractPowerSyncDatabase) {
      const transaction = await database.getNextCrudTransaction();
      if (!transaction) return;

      for (const op of transaction.crud) {
        const record = { ...op.opData, id: op.id };
        // upload to your backend API
      }

      await transaction.complete();
    }
  }

  // connect the database to PowerSync Service
  const connector = new Connector();
  await db.connect(connector);
  ```

  ```typescript Node.js (TS)
  import { PowerSyncBackendConnector } from '@powersync/node';

  export class Connector implements PowerSyncBackendConnector {
      async fetchCredentials() {
          // for development: use development token
          return {
              endpoint: 'https://your-instance.powersync.com',
              token: 'your-development-token-here'
          };
      }

      async uploadData(database) {
        // upload to your backend API
      }
  }

  // connect the database to PowerSync Service
  const connector = new Connector();
  await db.connect(connector);
  ```

  ```kotlin Kotlin
  import com.powersync.PowerSyncCredentials
  import com.powersync.PowerSyncDatabase

  class MyConnector : PowerSyncBackendConnector {
    override suspend fun fetchCredentials(): PowerSyncCredentials {
      // for development: use development token
      return PowerSyncCredentials(
        endpoint = "https://your-instance.powersync.com",
        token = "your-development-token-here"
      )
    }

    override suspend fun uploadData(database: PowerSyncDatabase) {
      val transaction = database.getNextCrudTransaction() ?: return
      
      for (op in transaction.crud) {
        val record = op.opData + ("id" to op.id)
        // upload to your backend API
      }
      
      transaction.complete()
    }
  }

  // connect the database to PowerSync Service
  database.connect(MyConnector())
  ```

  ```swift Swift
  import PowerSync

  class Connector: PowerSyncBackendConnector {
    func fetchCredentials() async throws -> PowerSyncCredentials {
      // for development: use development token
      return PowerSyncCredentials(
        endpoint: "https://your-instance.powersync.com",
        token: "your-development-token-here"
      )
    }

    func uploadData(database: PowerSyncDatabase) async throws {
      guard let transaction = try await database.getNextCrudTransaction() else {
        return
      }
      
      for op in transaction.crud {
        var record = op.opData
        record["id"] = op.id
        // upload to your backend API
      }
      
      try await transaction.complete()
    }
  }

  // connect the database to PowerSync Service
  let connector = Connector()
  await db.connect(connector: connector)
  ```

  ```dart Dart/Flutter
  import 'package:powersync/powersync.dart';

  class Connector extends PowerSyncBackendConnector {
    @override
    Future<PowerSyncCredentials> fetchCredentials() async {
      return PowerSyncCredentials(
        endpoint: 'https://your-instance.powersync.com',
        token: 'your-development-token-here'
      );
    }

    @override
    Future<void> uploadData(PowerSyncDatabase database) async {
      final transaction = await database.getNextCrudTransaction();
      if (transaction == null) return;

      for (final op in transaction.crud) {
        final record = {...op.opData, 'id': op.id};
        // upload to your backend API
      }

      await transaction.complete();
    }
  }

  // connect the database to PowerSync Service
  final connector = Connector();
  await db.connect(connector);
  ```

  ```csharp .NET
  using System;
  using System.Collections.Generic;
  using System.Net.Http;
  using System.Text;
  using System.Text.Json;
  using System.Threading.Tasks;
  using PowerSync.Common.Client;
  using PowerSync.Common.Client.Connection;
  using PowerSync.Common.DB.Crud;

  public class MyConnector : IPowerSyncBackendConnector
  {
      public MyConnector()
      {
      }

      public async Task<PowerSyncCredentials?> FetchCredentials()
      {
          var powerSyncUrl = "https://your-instance.powersync.com";
          var authToken = "your-development-token-here";

          // Return credentials with PowerSync endpoint and JWT token
          return new PowerSyncCredentials(powerSyncUrl, authToken);
      }

      public async Task UploadData(IPowerSyncDatabase database)
      {
          // upload to your backend API
      }
  }

  // connect the database to PowerSync Service
  await db.Connect(new MyConnector());
  ```

  ```rust Rust
  use async_trait::async_trait;
  use powersync::{BackendConnector, PowerSyncCredentials, PowerSyncDatabase, SyncOptions};
  use powersync::error::PowerSyncError;
  use std::sync::Arc;

  struct MyBackendConnector {
      client: Arc<dyn http_client::HttpClient>,
      db: PowerSyncDatabase,
  }

  #[async_trait]
  impl BackendConnector for MyBackendConnector {
      async fn fetch_credentials(&self) -> Result<PowerSyncCredentials, PowerSyncError> {
          // for development: use development token
          Ok(PowerSyncCredentials {
              endpoint: "https://your-instance.powersync.com".to_string(),
              token: "your-development-token-here".to_string(),
          })
      }

      async fn upload_data(&self) -> Result<(), PowerSyncError> {
          let mut local_writes = self.db.crud_transactions();
          while let Some(tx) = local_writes.try_next().await? {
              // upload to your backend API
              tx.complete().await?;
          }
          Ok(())
      }
  }

  // connect the database to PowerSync Service
  db.connect(SyncOptions::new(MyBackendConnector {
      client,
      db: db.clone(),
  }))
  .await;
  ```
</CodeGroup>

Once connected, you can read from and write to the client-side SQLite database. Changes from your source database will be automatically synced down into the SQLite database. For client-side mutations to be uploaded back to your source database, you need to complete the backend integration as we'll explain below.
### Read Data

Read data using SQL queries. The data comes from your client-side SQLite database:

<CodeGroup>
      ```typescript React Native, Web, Node.js & Capacitor (TS)
      // Get all todos
      const todos = await db.getAll('SELECT * FROM todos');

      // Get a single todo
      const todo = await db.get('SELECT * FROM todos WHERE id = ?', [todoId]);

      // Watch for changes (reactive query)
      const stream = db.watch('SELECT * FROM todos WHERE list_id = ?', [listId]);
      for await (const todos of stream) {
        // Update UI when data changes
        console.log(todos);
      }

      // Note: The above example requires async iterator support in React Native. 
      // If you encounter issues, use one of these callback-based APIs instead:

      // Option 1: Using onResult callback
      // const abortController = new AbortController();
      // db.watch(
      //   'SELECT * FROM todos WHERE list_id = ?',
      //   [listId],
      //   {
      //     onResult: (todos) => {
      //       // Update UI when data changes
      //       console.log(todos);
      //     }
      //   },
      //   { signal: abortController.signal }
      // );

      // Option 2: Using the query builder API
      // const query = db
      //   .query({
      //     sql: 'SELECT * FROM todos WHERE list_id = ?',
      //     parameters: [listId]
      //   })
      //   .watch();
      // query.registerListener({
      //   onData: (todos) => {
      //     // Update UI when data changes
      //     console.log(todos);
      //   }
      // });
      ```

      ```kotlin Kotlin
      // Get all todos
      val todos = database.getAll("SELECT * FROM todos") { cursor ->
        Todo.fromCursor(cursor)
      }

      // Get a single todo
      val todo = database.get("SELECT * FROM todos WHERE id = ?", listOf(todoId)) { cursor ->
        Todo.fromCursor(cursor)
      }

      // Watch for changes
      database.watch("SELECT * FROM todos WHERE list_id = ?", listOf(listId))
        .collect { todos ->
          // Update UI when data changes
        }
      ```

      ```swift Swift
      // Get all todos
      let todos = try await db.getAll(
        sql: "SELECT * FROM todos",
        mapper: { cursor in
          TodoContent(
            description: try cursor.getString(name: "description")!,
            completed: try cursor.getBooleanOptional(name: "completed")
          )
        }
      )

      // Watch for changes
      for try await todos in db.watch(
        sql: "SELECT * FROM todos WHERE list_id = ?",
        parameters: [listId]
      ) {
        // Update UI when data changes
      }
      ```

      ```dart Dart/Flutter
      // Get all todos
      final todos = await db.getAll('SELECT * FROM todos');

      // Get a single todo
      final todo = await db.get('SELECT * FROM todos WHERE id = ?', [todoId]);

      // Watch for changes
      db.watch('SELECT * FROM todos WHERE list_id = ?', [listId])
        .listen((todos) {
          // Update UI when data changes
        });
      ```

      ```csharp .NET
      // Define a result type with properties matching schema columns (some columns omitted for brevity)
      // public class ListResult { public string id; public string name; public string owner_id; public string created_at; ... }

      // Use db.Get() to fetch a single row:
      var list = await db.Get<ListResult>("SELECT * FROM lists WHERE id = ?", [listId]);

      // Use db.GetAll() to fetch all rows:
      var lists = await db.GetAll<ListResult>("SELECT * FROM lists");

      // Watch for changes to query results
      var query = await db.Watch("SELECT * FROM lists", null, new WatchHandler<ListResult>
      {
          OnResult = (results) => Console.WriteLine($"Lists updated: {results.Length} items"),
          OnError = (error) => Console.WriteLine($"Error: {error.Message}")
      });

      // Call query.Dispose() to stop watching for updates
      query.Dispose();
      ```

      ```rust Rust
      use rusqlite::params;
      use futures::StreamExt; // for try_next() on the watch stream

      // Get all todos
      async fn get_all_todos(db: &PowerSyncDatabase) -> Result<(), PowerSyncError> {
          let reader = db.reader().await?;
          let mut stmt = reader.prepare("SELECT * FROM todos")?;
          let mut rows = stmt.query(params![])?;
          while let Some(row) = rows.next()? {
              let id: String = row.get("id")?;
              let description: String = row.get("description")?;
              // use row data
          }
          Ok(())
      }

      // Get a single todo
      async fn find_todo(db: &PowerSyncDatabase, todo_id: &str) -> Result<(), PowerSyncError> {
          let reader = db.reader().await?;
          let mut stmt = reader.prepare("SELECT * FROM todos WHERE id = ?")?;
          let mut rows = stmt.query(params![todo_id])?;
          while let Some(row) = rows.next()? {
              let id: String = row.get("id")?;
              let description: String = row.get("description")?;
              println!("Found todo: {id}, {description}");
          }
          Ok(())
      }

      // Watch for changes
      async fn watch_todos(db: &PowerSyncDatabase, list_id: &str) -> Result<(), PowerSyncError> {
          let stream = db.watch_statement(
              "SELECT * FROM todos WHERE list_id = ?".to_string(),
              params![list_id],
              |stmt, params| {
                  let mut rows = stmt.query(params)?;
                  let mut mapped = vec![];
                  while let Some(row) = rows.next()? {
                      mapped.push(() /* TODO: Read row into struct */);
                  }
                  Ok(mapped)
              },
          );
          let mut stream = std::pin::pin!(stream);
          while let Some(_event) = stream.try_next().await? {
              // Update UI when data changes
          }
          Ok(())
      }
      ```
    </CodeGroup>

<Tip>
  **Learn More**
  
  - [Reading Data](/client-sdks/reading-data) - Details on querying synced data
  - [ORMs Overview](/client-sdks/orms/overview) - Using type-safe ORMs with PowerSync
  - [Live Queries / Watch Queries](/client-sdks/watch-queries) - Building reactive UIs with automatic updates
</Tip>

### Write Data

Write data using SQL `INSERT`, `UPDATE`, or `DELETE` statements. PowerSync automatically queues these mutations and uploads them to your backend via the `uploadData()` function, once you've fully implemented your _backend connector_ (as we'll talk about below).

<CodeGroup>
      ```typescript React Native (TS), Web & Node.js
      // Insert a new todo
      await db.execute(
        'INSERT INTO todos (id, created_at, list_id, description) VALUES (uuid(), date(), ?, ?)',
        [listId, 'Buy groceries']
      );

      // Update a todo
      await db.execute(
        'UPDATE todos SET completed = 1, completed_at = date() WHERE id = ?',
        [todoId]
      );

      // Delete a todo
      await db.execute('DELETE FROM todos WHERE id = ?', [todoId]);
      ```

      ```kotlin Kotlin
      // Insert a new todo
      database.writeTransaction { ctx ->
        ctx.execute(
          sql = "INSERT INTO todos (id, created_at, list_id, description) VALUES (uuid(), date(), ?, ?)",
          parameters = listOf(listId, "Buy groceries")
        )
      }

      // Update a todo
      database.execute(
        sql = "UPDATE todos SET completed = 1, completed_at = date() WHERE id = ?",
        parameters = listOf(todoId)
      )

      // Delete a todo
      database.execute(
        sql = "DELETE FROM todos WHERE id = ?",
        parameters = listOf(todoId)
      )
      ```

      ```swift Swift
      // Insert a new todo
      try await db.execute(
        sql: "INSERT INTO todos (id, created_at, list_id, description) VALUES (uuid(), date(), ?, ?)",
        parameters: [listId, "Buy groceries"]
      )

      // Update a todo
      try await db.execute(
        sql: "UPDATE todos SET completed = 1, completed_at = date() WHERE id = ?",
        parameters: [todoId]
      )

      // Delete a todo
      try await db.execute(
        sql: "DELETE FROM todos WHERE id = ?",
        parameters: [todoId]
      )
      ```

      ```dart Dart/Flutter
      // Insert a new todo
      await db.execute(
        'INSERT INTO todos (id, created_at, list_id, description) VALUES (uuid(), date(), ?, ?)',
        [listId, 'Buy groceries']
      );

      // Update a todo
      await db.execute(
        'UPDATE todos SET completed = 1, completed_at = date() WHERE id = ?',
        [todoId]
      );

      // Delete a todo
      await db.execute('DELETE FROM todos WHERE id = ?', [todoId]);
      ```

      ```csharp .NET
      // Insert a new todo
      await db.Execute(
        "INSERT INTO todos (id, created_at, list_id, description) VALUES (uuid(), datetime(), ?, ?)",
        [listId, "Buy groceries"]
      );

      // Update a todo
      await db.Execute(
        "UPDATE todos SET completed = 1, completed_at = datetime() WHERE id = ?",
        [todoId]
      );

      // Delete a todo
      await db.Execute("DELETE FROM todos WHERE id = ?", [todoId]);
      ```

      ```rust Rust
      use rusqlite::params;

      // Insert a new todo
      async fn insert_todo(
          db: &PowerSyncDatabase,
          list_id: &str,
          description: &str,
      ) -> Result<(), PowerSyncError> {
          let writer = db.writer().await?;
          writer.execute(
              "INSERT INTO todos (id, created_at, list_id, description) VALUES (uuid(), date(), ?, ?)",
              params![list_id, description],
          )?;
          Ok(())
      }

      // Update a todo
      async fn complete_todo(db: &PowerSyncDatabase, todo_id: &str) -> Result<(), PowerSyncError> {
          let writer = db.writer().await?;
          writer.execute(
              "UPDATE todos SET completed = 1, completed_at = date() WHERE id = ?",
              params![todo_id],
          )?;
          Ok(())
      }

      // Delete a todo
      async fn delete_todo(db: &PowerSyncDatabase, todo_id: &str) -> Result<(), PowerSyncError> {
          let writer = db.writer().await?;
          writer.execute("DELETE FROM todos WHERE id = ?", params![todo_id])?;
          Ok(())
      }
      ```
</CodeGroup>

<Note>
  **Best practice**: Use UUIDs when inserting new rows on the client side. UUIDs can be generated offline/locally, allowing for unique identification of records created in the client database before they are synced to the server. See [Client ID](/sync/advanced/client-id) for more details.
</Note>

<Tip>
  **Learn More**
  
  For more details, see the [Writing Data](/client-sdks/writing-data) page.
</Tip>

# Next Steps

For production deployments, you'll need to:

1. **[Implement Authentication](/configuration/auth/overview)**: Replace development tokens with proper JWT-based authentication. PowerSync supports various authentication providers including Supabase, Firebase Auth, Auth0, Clerk, and custom JWT implementations.
2. **Configure & Integrate Your Backend Application**: Set up your backend to handle mutations uploaded from clients.
    - [Server-Side Setup](/configuration/app-backend/setup)
    - [Client-Side Integration](/configuration/app-backend/client-side-integration)

### Additional Resources

- Learn more about [Sync Rules](/sync/rules/overview) for advanced data filtering
- Explore [Live Queries / Watch Queries](/client-sdks/watch-queries) for reactive UI updates
- Check out [Example Projects](/intro/examples) for complete implementations
- Review the [Client SDK References](/client-sdks/overview) for client-side platform-specific details

# Questions?

Try "Ask AI" on this site which is trained on all our documentation, repositories and Discord discussions. Also join us on [our community Discord server](https://discord.gg/powersync) where you can browse topics from the PowerSync community and chat with our team.
