---
title: "Next.js + PowerSync"
sidebarTitle: "Next.js"
description: "A guide for creating a new Next.js application with PowerSync for offline/local first functionality"
keywords: ["next.js", "web"]
---

## Introduction
This guide walks through integrating PowerSync into a Next.js application for offline-first functionality with local-first storage and efficient synchronization.

<Note>PowerSync does not work with SSR. In this guide we disable SSR across the entire app using the `'use client'` directive. For pages that don't require PowerSync, you can still use SSR by only wrapping PowerSync-dependent pages with the SystemProvider.</Note>

## Setup

### Next.js Project Setup
Bootstrap a new Next.js application using [`create-next-app`](https://nextjs.org/docs/app/api-reference/cli/create-next-app).
<CodeGroup>

```shell npm
npx create-next-app@latest my-powersync-app
```

```shell yarn
yarn create next-app my-powersync-app
```

```shell pnpm
pnpm create next-app my-powersync-app
```

</CodeGroup>

When running this command you'll be presented with a few options. The PowerSync suggested selections are:
```shell
Would you like to use TypeScript?  Yes
Would you like to use ESLint?  Yes
Would you like to use Tailwind CSS?  Yes
Would you like your code inside a `src/` directory?  Yes
Would you like to use App Router? (recommended)   Yes
Would you like to use Turbopack for `next dev`?  Yes
Would you like to customize the import alias (`@/*` by default)?  Yes
```

### Install PowerSync Dependencies

Using PowerSync in a Next.js application requires the [PowerSync Web SDK](https://www.npmjs.com/package/@powersync/web) and its peer dependencies.

We'll also install [`@powersync/react`](https://www.npmjs.com/package/@powersync/react), which provides hooks and providers for easier integration.

<CodeGroup>

```shell npm
npm install @powersync/web @journeyapps/wa-sqlite @powersync/react
```

```shell yarn
yarn add @powersync/web @journeyapps/wa-sqlite @powersync/react
```

```shell pnpm
pnpm install @powersync/web @journeyapps/wa-sqlite @powersync/react
```

</CodeGroup>

<Note>This SDK currently requires [@journeyapps/wa-sqlite](https://www.npmjs.com/package/@journeyapps/wa-sqlite) as a peer dependency.</Note>

### Copy PowerSync Worker Assets

PowerSync uses Web Workers for database and sync operations. These worker files need to be copied to your `public` directory. Add the following scripts to your `package.json`:

```json package.json
{
  "scripts": {
    "copy-assets": "powersync-web copy-assets -o public",
    "postinstall": "pnpm copy-assets"
  }
}
```

Run the copy-assets script to copy the worker files:

<CodeGroup>

```shell npm
npm run copy-assets
```

```shell yarn
yarn copy-assets
```

```shell pnpm
pnpm copy-assets
```

</CodeGroup>

This will create a `@powersync` directory in your `public` folder containing the necessary worker files.

## Next.js Config Setup

PowerSync works with Turbopack. The `next.config.js` only needs minimal configuration:

```javascript next.config.js
module.exports = {
  images: {
    disableStaticImages: true
  },
  turbopack: {}
};
```

Run `pnpm dev` to start the development server and check that everything compiles correctly before moving onto the next section.

## Configure a PowerSync Instance
Now that we've got our project setup, let's create a new PowerSync Cloud instance and connect our client to it.
For the purposes of this demo, we'll be using Supabase as the backend source database that PowerSync will connect to.

To set up a new PowerSync instance, follow the steps covered in the [Installation - Database Connection](/configuration/source-db/connection) docs page.

## Configure PowerSync in your project
### Add core PowerSync files
Start by adding a new directory in `./src/lib` named `powersync`.

#### `AppSchema`
Create a new file called `AppSchema.ts` in the newly created `powersync` directory and add your App Schema to the file. Here is an example of this.
```typescript lib/powersync/AppSchema.ts
import { column, Schema, Table } from '@powersync/web';

const lists = new Table({
  created_at: column.text,
  name: column.text,
  owner_id: column.text
});

const todos = new Table(
  {
    list_id: column.text,
    created_at: column.text,
    completed_at: column.text,
    description: column.text,
    created_by: column.text,
    completed_by: column.text,
    completed: column.integer
  },
  { indexes: { list: ['list_id'] } }
);

export const AppSchema = new Schema({
  todos,
  lists
});

// For types
export type Database = (typeof AppSchema)['types'];
export type TodoRecord = Database['todos'];
// OR:
// export type Todo = RowType<typeof todos>;
export type ListRecord = Database['lists'];
```

This defines the local SQLite database schema and PowerSync will hydrate the tables once the SDK connects to the PowerSync instance.

#### `BackendConnector`

Create a new file called `BackendConnector.ts` in the `powersync` directory and add the following to the file.
```typescript lib/powersync/BackendConnector.ts
import { AbstractPowerSyncDatabase, PowerSyncBackendConnector, UpdateType } from '@powersync/web';

export class BackendConnector implements PowerSyncBackendConnector {
    private powersyncUrl: string | undefined;
    private powersyncToken: string | undefined;

    constructor() {
        this.powersyncUrl = process.env.NEXT_PUBLIC_POWERSYNC_URL;
        // This token is for development only.
        // For production applications, integrate with an auth provider or custom auth.
        this.powersyncToken = process.env.NEXT_PUBLIC_POWERSYNC_TOKEN;
    }

    async fetchCredentials() {
        // TODO: Use an authentication service or custom implementation here.
        if (this.powersyncToken == null || this.powersyncUrl == null) {
            return null;
        }

        return {
            endpoint: this.powersyncUrl,
            token: this.powersyncToken
        };
    }

    async uploadData(database: AbstractPowerSyncDatabase): Promise<void> {
        const transaction = await database.getNextCrudTransaction();

        if (!transaction) {
            return;
        }

        try {
            for (const op of transaction.crud) {
              // The data that needs to be changed in the remote db
              const record = { ...op.opData, id: op.id };
              switch (op.op) {
                case UpdateType.PUT:
                  // TODO: Instruct your backend API to CREATE a record
                  break;
                case UpdateType.PATCH:
                  // TODO: Instruct your backend API to PATCH a record
                  break;
                case UpdateType.DELETE:
                  // TODO: Instruct your backend API to DELETE a record
                  break;
              }
            }
            await transaction.complete();
        } catch (error: any) {
            if (shouldDiscardDataOnError(error)) {
                // Instead of blocking the queue with these errors, discard the (rest of the) transaction.
                // Note that these errors typically indicate a bug in the application.
                // If protecting against data loss is important, save the failing records
                // elsewhere instead of discarding, and/or notify the user.
                console.error(`Data upload error - discarding`, error);
                await transaction.complete();
            } else {
                // Error may be retryable - e.g. network error or temporary server error.
                // Throwing an error here causes this call to be retried after a delay.
                throw error;
            }
        }
    }
}

function shouldDiscardDataOnError(error: any) {
    // TODO: Ignore non-retryable errors here
    return false;
}
```

There are two core functions to this file:
* `fetchCredentials()` - Used to return a JWT token to the PowerSync Service for authentication.
* `uploadData()` - Used to upload changes captured in the local SQLite database that need to be sent to the backend source database, in this case Supabase. We'll get back to this further down.

The `shouldDiscardDataOnError` helper function distinguishes between errors that should be retried (network issues, temporary server errors) and those that won't succeed on retry (validation errors, malformed requests). Customize this based on your backend's error responses to prevent non-retryable errors from blocking the upload queue.

You'll notice that we need to add a `.env` file to our project which will contain two variables:
* `NEXT_PUBLIC_POWERSYNC_URL` - This is the PowerSync instance url. You can grab this from the PowerSync Cloud dashboard.
* `NEXT_PUBLIC_POWERSYNC_TOKEN` - For development purposes we'll be using a development token. To generate one, please follow the steps outlined in [Development Token](/configuration/auth/development-tokens) from our installation docs.

### Create Providers

Create a new directory in `./src/components` named `providers`

#### `SystemProvider`
Add a new file in the newly created `providers` directory called `SystemProvider.tsx`.

```typescript components/providers/SystemProvider.tsx
'use client';

import { AppSchema } from '@/lib/powersync/AppSchema';
import { BackendConnector } from '@/lib/powersync/BackendConnector';
import { PowerSyncContext } from '@powersync/react';
import { PowerSyncDatabase, WASQLiteOpenFactory, createBaseLogger, LogLevel } from '@powersync/web';
import React, { Suspense } from 'react';

const logger = createBaseLogger();
logger.useDefaults();
logger.setLevel(LogLevel.DEBUG);

const factory = new WASQLiteOpenFactory({
  dbFilename: 'powersync.db',
  // Use the pre-bundled workers from public/@powersync/
  worker: '/@powersync/worker/WASQLiteDB.umd.js'
});

const powerSync = new PowerSyncDatabase({
  database: factory,
  schema: AppSchema,
  flags: {
    disableSSRWarning: true
  },
  sync: {
    // Use the pre-bundled sync worker from public/@powersync/
    worker: '/@powersync/worker/SharedSyncImplementation.umd.js'
  }
});

const connector = new BackendConnector();
powerSync.connect(connector);

export const SystemProvider = ({ children }: { children: React.ReactNode }) => {
  return (
    <Suspense fallback={<div>Loading...</div>}>
      <PowerSyncContext.Provider value={powerSync}>{children}</PowerSyncContext.Provider>
    </Suspense>
  );
};

export default SystemProvider;
```

The `SystemProvider` initializes the `PowerSyncDatabase` with the AppSchema and configures it to use the pre-bundled worker files copied to the `public` directory. The `disableSSRWarning: true` flag suppresses SSR-related warnings since PowerSync only runs on the client.

We also instantiate our `BackendConnector` and pass an instance to `powerSync.connect()`. This connects to the PowerSync instance, validates the token from the `fetchCredentials` function, and starts syncing with the PowerSync Service.

#### Update `layout.tsx`

In your main `layout.tsx`, update the `RootLayout` function to use the `SystemProvider`. The `'use client'` directive at the top ensures this layout runs on the client side.

```typescript app/layout.tsx
'use client';

import { SystemProvider } from '@/components/providers/SystemProvider';
import React from 'react';
import './globals.css';

export default function RootLayout({ children }: { children: React.ReactNode }) {
  return (
    <html lang="en">
      <body>
        <SystemProvider>{children}</SystemProvider>
      </body>
    </html>
  );
}
```

#### Use PowerSync

##### Reading Data
In your `page.tsx` you can use the `useQuery` hook or other PowerSync functions to read data from the SQLite database and render the results.

```typescript app/page.tsx
'use client';

import { useQuery, useStatus } from '@powersync/react';

export default function Page() {
  // Get database status information e.g. downloading, uploading and lastSynced dates
  const status = useStatus();

  // Reactive query - automatically updates when data changes
  const { data: lists } = useQuery('SELECT * FROM lists');

  if (!status.hasSynced) {
    return <div>Syncing...</div>;
  }

  return (
    <ul>
      {lists.map((list) => (
        <li key={list.id}>{list.name}</li>
      ))}
    </ul>
  );
}
```

You can also use the `usePowerSync` hook to access the PowerSync database instance directly for non-reactive queries:

```typescript
import { usePowerSync } from '@powersync/react';

const powersync = usePowerSync();

// One-time query
const lists = await powersync.getAll('SELECT * FROM lists');
```

##### Writing Data
Use the `execute` function to write data into the local SQLite database:

```typescript
await powersync.execute(
  'INSERT INTO lists (id, created_at, name, owner_id) VALUES (?, ?, ?, ?)',
  [uuid(), new Date().toISOString(), 'Test', user_id]
);
```

Changes made to the local data are stored in the upload queue and processed by the `uploadData` function in the BackendConnector class.
