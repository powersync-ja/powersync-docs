---
title: CloudCode (for MongoDB Backend Functionality)
description:
---

We've made optional functionality available to MongoDB customers that handles the [backend integration](/configuration/app-backend/setup) required by PowerSync.

This makes PowerSync easier to implement for developers migrating from [MongoDB Atlas Device Sync](/migration-guides/atlas-device-sync) who prefer not having to maintain their own backend code and infrastructure (PowerSync's [typical architecture](/configuration/app-backend/setup) is to use your own backend to process mutations uploaded from clients, and to generate JWTs for authentication if needed).

Specifically, you can use the CloudCode feature of JourneyApps Platform, a [sibling product](https://journeyapps.com) of PowerSync. [CloudCode](https://docs.journeyapps.com/reference/cloudcode/cloudcode-overview) is a serverless cloud functions engine based on Node.js and AWS Lambda. It's provided as a fully-managed service running on the same cloud infrastructure as the rest of PowerSync Cloud. PowerSync and JourneyApps Platform share the same login system, so you don’t need to create a separate account to use CloudCode. For further background, see [this post on our blog](https://www.powersync.com/blog/turnkey-backend-functionality-conflict-resolution-for-powersync).

<Note>
    We are currently making JourneyApps Platform CloudCode available for free to all our customers who use PowerSync with MongoDB. It does require a bit of "white glove" onboarding from our team. [Contact us](/resources/contact-us) if you want to use this functionality.
</Note>


# Using CloudCode for MongoDB Backend Functionality

There is a MongoDB template available in CloudCode that provides the backend functionality needed for a PowerSync MongoDB implementation. Here is how to use it:

## Create a New JourneyApps Platform Project

To create a new JourneyApps Platform project in order to use CloudCode:

<Steps>
    <Step>
        Navigate to the [JourneyApps Admin Portal](https://accounts.journeyapps.com/portal/admin). You should see a list of your projects if you've created any.
        <Frame>
            <img src="/images/usage/tools/JourneyApps_Project_1.png" />
        </Frame>
    </Step>
    <Step>
        Select **Create Project** at the top right of the screen.
        <Frame>
            <img src="/images/usage/tools/JourneyApps_Project_2.png" />
        </Frame>
    </Step>
    <Step>
        Select **JourneyApps Platform Project** and click **Next**.
        <Frame>
            <img src="/images/usage/tools/JourneyApps_Project_3.png" />
        </Frame>
    </Step>
    <Step>
        Enter a project name and click **Next**.
        <Frame>
            <img src="/images/usage/tools/JourneyApps_Project_4.png" />
        </Frame>
    </Step>
    <Step>
        There are options available for managing version control for the project. For simplicity we recommend selecting **Basic (Revisions)** and **JourneyApps** as the Git provider.
        <Frame>
            <img src="/images/usage/tools/JourneyApps_Project_5.png" />
        </Frame>
    </Step>
    <Step>
        Select **TypeScript** as your template language, and **MongoDB CRUD & Auth Backend** as your template. Then click **Create App**.
        <Frame>
            <img src="/images/usage/tools/JourneyApps_Project_6.png" />
        </Frame>
    </Step>
</Steps>

## Overview of the CloudCode Tasks Created From the Template

To view the CloudCode tasks that were created in the new project using this template, select **CloudCode** at the top of the IDE:

<Frame>
    <img src="/images/usage/tools/CloudCode.png" />
</Frame>

Here you will find four CloudCode tasks:
<Frame>
    <img src="/images/usage/tools/CloudCode-tasks.png" />
</Frame>

Here's the purpose of each task:

<table>
    <thead>
        <tr>
            <th>Task</th>
            <th>Used For</th>
            <th>Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td>`generate_keys`</td>
            <td>
                [Authentication Integration](/configuration/app-backend/setup)
            </td>
            <td>This is a task that can be used to generate a private/public key pair which the `jwks` and `token` tasks (see below) require. This task does **not** expose an HTTP endpoint and should only be used for development and getting started.</td>
        </tr>
        <tr>
            <td>`jwks`</td>
            <td>
                [Authentication Integration](/configuration/app-backend/setup)
            </td>
            <td>This task [exposes an HTTP endpoint](https://docs.journeyapps.com/reference/cloudcode/triggering-a-cloudcode-task/trigger-cc-via-http) which has a `GET` function which returns the public [JWKS](https://stytch.com/blog/understanding-jwks/) details.</td>
        </tr>
        <tr>
            <td>`token`</td>
            <td>
                [Authentication Integration](/configuration/app-backend/setup)
            </td>
            <td>This task exposes an HTTP endpoint which has a `GET` function. The HTTP endpoint can be called by your [`fetchCredentials()` function](/configuration/app-backend/client-side-integration) when implementing the PowerSync Client SDK, to generate a JWT that the Client SDK can use to authenticate against the PowerSync Service.</td>
        </tr>
        <tr>
            <td>`upload`</td>
            <td>
                [Client Mutations](/configuration/app-backend/setup)
            </td>
            <td>This task exposes an HTTP endpoint which has a `POST` function which is used to process uploaded mutations from a PowerSync client and persist it to the source MongoDB database. The HTTP endpoint can be called by your [`uploadData()` function](/configuration/app-backend/client-side-integration) when implementing the PowerSync Client SDK.</td>
        </tr>
    </tbody>
</table>

<Tip>
    If you will not be using [Custom Authentication](/configuration/auth/custom), you do not need the authentication-related tasks. Some [authentication providers](/configuration/auth/overview#common-authentication-providers) (e.g. Auth0, Clerk, Stytch, Keycloak, Azure AD, Google Identity, WorkOS, etc.) already generate JWTs for users which PowerSync can work with directly. If you are _not_ using one of those authentication providers, you will need to implement [Custom Authentication](/configuration/auth/custom)
</Tip>

## Setup: Deployment Configuration

Before using the tasks, we need to configure a "deployment".
1. At the top of the IDE, select **Deployments**.
2. Create a new deployment by using the **+** button at the top right, _or_ use the default `Testing` deployment. You can configure different deployments for different environments (e.g. staging, production)
3. Now select the **Deployment settings** button for the deployment.
4. In the **Deployment settings** - **General** tab, capture a **Domain** value in the text field. This domain name determines where the HTTP endpoints exposed by these CloudCode tasks can be accessed. The application will validate the domain name to make sure it's available.
5. Select **Save**.
6. Deploy the deployment: you can do so by selecting the **Deploy app** button, which can be found on the far right for each of the deployments you have configured. After the deployment is completed, it will take a few minutes for the domain to be available.
7. Your new domain will be available at `<domain_name>.poweredbyjourney.com`. Open the browser and navigate to the new domain. You should be presented with `Cannot GET /`, because there is no index route.


## Setup: Authentication Integration (Optional)

<Tip>
    If you will not be using [Custom Authentication](/configuration/auth/custom), you can skip this part. See the explanatory note about authentication above.
</Tip>

### 1. Generate Key Pair

First, you need to generate a public/private key pair. Do the following to generate the key pair:

1. Open the `generate_keys` CloudCode task.
2. Select the **Test CloudCode Task** button at the top right. This will print the public and private key in the task logs window.
<Frame>
    <img src="/images/usage/tools/test-cloudcode-task.png" />
</Frame>
3. Copy and paste the `POWERSYNC_PUBLIC_KEY` and `POWERSYNC_PRIVATE_KEY` to a file — we'll need this in the next step.

<Note>
    This step is only meant for testing and development because the keys are printed in the log files.
    For production, [generate a key pair locally](https://github.com/powersync-ja/powersync-jwks-example?tab=readme-ov-file#1-generate-a-key-pair) and move onto step 2 and 3.
</Note>

### 2. Configure Environment Variables

The following variables need to be set on the deployment for authentication integration purposes:

* `POWERSYNC_PUBLIC_KEY` - This is the `POWERSYNC_PUBLIC_KEY` from the values generated in step 1.
* `POWERSYNC_PRIVATE_KEY` - This is the `POWERSYNC_PRIVATE_KEY` from the values generated in step 1.
* `POWERSYNC_URL` - This is your PowerSync instance URL that can be found in the [PowerSync Dashboard](https://dashboard.powersync.com/).

See the [How to Set Environment Variables](#how-to-set-environment-variables) section below for instructions.

### 3. Test
Open your browser and navigate to `<domain_name>.poweredbyjourney.com/jwks` (using the domain name you picked in [Setup: Deployment Configuration](#setup:-deployment-configuration))

If the setup was successful, the `jwks` task will render the keys in JSON format. Make sure the format of your JWKS keys matches the format [in this example](https://hlstmcktecziostiaplz.supabase.co/functions/v1/powersync-jwks) JWKS endpoint.


## Setup: Handling Client Mutations

The following variables need to be set on the deployment for the purpose of handling uploaded client mutations:
* `POWERSYNC_URL` - This is your PowerSync instance URL that can be found in the [PowerSync Dashboard](https://dashboard.powersync.com/).
* `MONGO_URI` - This is the URI of your MongoDB source database e.g. `mongodb+srv://<username>:<password>@<database_domain>/<database>`

See the next section for instructions.


## How to Set Environment Variables

To set environment variables, do the following:
1. At the top of the IDE, select **Deployments**.
2. Click on **Deployment settings** for the relevant deployment.
3. Select the **Environment Variables** tab.
<Frame>
    <img src="/images/usage/tools/cloudcode-envvar.png" />
</Frame>
4. Capture the variable name in the **Name** text field.
5. Capture the variable value in the **Value** text field.
6. (Suggested) Check the **Masked** checkbox to obfuscate the variable value for security purposes.
7. Repeat until all the variables are added.

To finalize the setup, do the following:
1. Select the **Save** button. This is important, otherwise the variables will not save.
2. Deploy the deployment: you can do so by selecting the **Deploy app** button.


## Usage: Authentication Integration (Optional)

<Note>Make sure you've configured a deployment and set up environment variables as described in the **Setup** steps above before using the HTTP API endpoints exposed by the CloudCode tasks</Note>

### Token
You would call the `token` HTTP API endpoint when you [implement](/configuration/app-backend/client-side-integration) the `fetchCredentials()` function in your client application.

Send an HTTP GET request to `<domain_name>.poweredbyjourney.com/token?user_id=<user_id>` to fetch a JWT for a user. You must provide a `user_id` in the query string of the request, as this is included in the JWT that is generated.

The response of the request will be structured like this:
```json
{"token":"..."}
```

### JWKS
The `jwks` HTTP API endpoint is used by PowerSync to validate the token returned from the `<domain_name>.poweredbyjourney.com/token` endpoint. This URL must be set in the configuration of your PowerSync instance.

Send an HTTP GET request to `<domain_name>.poweredbyjourney.com/jwks`.

An example of the response format can be found using [this link](https://hlstmcktecziostiaplz.supabase.co/functions/v1/powersync-jwks).


## Usage: Handling Client Mutations

### Upload
You would call the `upload` HTTP API endpoint when you [implement](/configuration/app-backend/client-side-integration) the `uploadData()` function in your client application.

Send an HTTP POST request to `<domain_name>.poweredbyjourney.com/upload`

The body of the request payload should look like this:
```json
{
  "batch": [{
    "op": "PUT",
    "table": "lists",
    "id": "61d19021-0565-4686-acc4-3ea4f8c48839",
    "data": {
      "created_at": "2024-10-31 10:33:24",
      "name": "Name",
      "owner_id": "8ea4310a-b7c0-4dd7-ae54-51d6e1596b83"
    }
  }]
}
```

  * `batch` should be an array of mutations from the PowerSync Client SDK.
  * `op` refers to the type of each mutation recorded by the PowerSync Client SDK (`PUT`, `PATCH` or `DELETE`). Refer to [Writing Data](/client-sdks/writing-data) and [Writing Client Changes](/handling-writes/writing-client-changes) for details.
  * `table` refers to the table in SQLite where the mutation originates from, and should match the name of a collection in MongoDB.

The API will respond with HTTP status `200` if the write was successful.

## Customization: Handling Client Mutations

You can make changes to the way the `upload` task writes data to the source MongoDB database. 

Here is how:

1. Go to **CloudCode** at the top of the IDE in your JourneyApps Platform project
2. Select and expand the `upload` task in the panel on the left.
3. The `index.ts` contains the entry point function that accepts the HTTP request and has a `MongoDBStorage` class which interacts with the MongoDB database to perform inserts, updates and deletes. To adjust how mutations are performed, take a look at the `updateBatch` function.

## Static IP Addresses (MongoD Atlas)

To enable static IP addresses for CloudCode to connect to the MongoDB database, you need to complete the following steps:

<Info>
    Static IP addresses are only availible in the EU and US regions.
</Info>

<Steps>
  <Step title="Converting the SRV record to get the replicas connection/port uri">
    
    Use the `@journeyapps/https-proxy-socket` helper to convert the SRV record to get the MongoDB replica's connection/port uri.

    Using username and password:
    ```bash
    npx @journeyapps/https-proxy-socket mongo-replicas mongodb+srv://your_username:your_password@you_cluster.mongodb.net
    ```
    Without username and password:
    ```bash
    npx @journeyapps/https-proxy-socket mongo-replicas mongodb+srv://you_cluster.mongodb.net
    ```

    The output will be a JSON object with the following structure:

    ```javascript
    {
        replicas: 'uri_1,uri_2,etc.';
    }
    ```

    <Note>
        Keep record of the output and use it in the next step.
    </Note>
  </Step>
  <Step title="Request an egress token from the PowerSync support team.">
    Request a egress token from the PowerSync support team by sending an email to support@powersync.com or by visiting the [PowerSync Support](https://support.powersync.com/) portal.

    Make sure to include the following in the request:
    * The list of replicas connection/port uri from step 1
    * The URL to the Oxide Project that houses the CloudCode tasks
    * If you need to configure multiple static IP addresses for different deployments/environments, please include the list of deployments along with their associated region.

    The PowerSync support team will respond with an egress token and the group associated with the static IP addresses you should use. Keep record of the egress token and use it in the next step. 
    
    Add the egress token to the environment variables of the deployment(s). The environment variable name should be `CLOUDCODE_EGRESS_TOKEN`.

    Here's a list of the IP addresses with their associated group, please include both IP addresses for each group:

    | Region | Group | IP Address 1 | IP Address 2 |
    |--------|-------|--------------|--------------|
    | EU | A | 52.17.49.128 | 52.18.47.75 |
    | EU | B | 52.50.132.241 | 52.209.110.101 |
    | EU | C | 52.214.251.96 | 54.229.199.114 |
    | US | A | 18.210.190.20 | 34.192.9.106 |
    | US | B | 18.211.143.94 | 34.193.213.9 |
    | US | C | 54.210.43.215 | 52.201.67.23 |
  </Step>
  <Step title="Configure the IP address in the MongoDB Atlas cluster.">
    Go to the MongoDB Atlas cluster and configure the IP address for the MongoDB project by doing the following:

    1. Navigate to **Database & Network Access**
    2. Select **IP Access List**
    3. Click on **AD IP ADDRESS**
    4. Capture the first IP address based on the region (EU or US)
    5. Add a comment e.g. "PowerSync CloudCode Static IP Address 1"
    6. Click on **Confirm**
    7. Capture the second IP address based on the region (EU or US)
    8. Add a comment e.g. "PowerSync CloudCode Static IP Address 2"
    8. Click on **Confirm**

  </Step>
    <Step title="Update the `upload` CloudCode task to use the proxy helper before implementing the MongoDB connection">
        
        In the latest version of the CloudCode tasks, the `upload` task has been updated to include the the proxy helper and the related code snippets have been commented out. Uncomment the code snippets to use the proxy helper and make sure to add an additional environment variable `CLOUDCODE_EGRESS_TOKEN` to the deployment.
        
        If you are using an older version of the CloudCode tasks, you need to follow the steps below to update the `upload` CloudCode task to use the proxy helper.
        ### Step 1: Add the [`@journeyapps/https-proxy-socket`](https://github.com/journeyapps/https-proxy-socket) npm package to the `upload` CloudCode task.

        1. Right-click on the CloudCode task name and select the **Add Node.js package** option.
        2. Search for `@journeyapps/https-proxy-socket` and select the package to add it to the `upload` CloudCode task.
        3. Right-click on the CloudCode task name and select the **Update yarn.lock** option.

        <Info>
            To confirm the package was added successfully, select the **Deploy to testing** button or press the **Ctrl/CMD + S** to save and deploy the `upload` CloudCode task.
        </Info>

        ### Step 2: Update the `MongoDBStorage` class in the `index.ts` file of the `upload` CloudCode task to use the proxy helper before implementing the MongoDB connection.

        ```typescript
        import { useProxyForMongo } from '@journeyapps/https-proxy-socket';

        .... previous code ....

        class MongoDBStorage {
            public client: any;
            public db: any;
            public close: any;

            constructor(uri: string) {
                const TOKEN = process.env.CLOUDCODE_EGRESS_TOKEN;
                const PROXY = "us-cc-proxy.journeyapps.com" // or za-cc-proxy.journeyapps.com for EU;
                const PROXY_PORT = 443;

                if (!MONGO_URI) {
                    console.log(`Env variable MONGO_URI is not set, please add the environment variable in the Deployment settings`);
                }
                this.close = useProxyForMongo({
                    proxy: PROXY,
                    auth: TOKEN,
                });
                this.client = new MongoClient(uri, {
                    proxyPort: PROXY_PORT,
                    proxyHost: PROXY
                });
                this.db = this.client.db();
            }
        }
        ```
        <Info>
            The EU region uses the `za-cc-proxy.journeyapps.com` proxy.
        </Info>

        Make sure to rename the `close` function in the `MongoDBStorage` class to `closeConnection` to avoid duplicate function names and call the new `close` function from the `@journeyapps/https-proxy-socket` helper when the MongoDB connection is no longer needed.

        ```typescript
        public async closeConnection() {
            if (this.client) {
                this.close(); // Call the proxy helper to close the connection
                await this.client.close(true);
            }
        }
        ```
    </Step>
    <Step title="Test the setup.">
        Test the setup by sending a mutation to the `upload` HTTP API endpoint.
    </Step>
</Steps>

## Production Considerations

### HTTP Endpoint Authentication

By default, the CloudCode tasks will authenticate all requests to help you get started quickly. However, in production, you will need to set up authentication on the HTTP endpoints exposed by the CloudCode tasks.
Each CloudCode task includes an `authenticate` function. This function is called before the request is processed and can be used to authenticate the request.

Here's an example of how to authenticate the request where the request header contains a `Authorization` header with a Bearer token and uses the [`jsonwebtoken`](https://www.npmjs.com/package/jsonwebtoken) library to verify the token using a secret key stored in an environment variable.

```typescript
import jwt from 'jsonwebtoken';

const JWT_SECRET = process.env.JWT_SECRET;

export async function authenticate({ request, access }) {
    // We check for a token in the Authorization header, and
    // do a database lookup based on this.
    const auth = request.header('Authorization');

    const match = /^Bearer (\w+)$/.exec(auth);
    if(match == null) {
       return access.unauthorized();
    }

    // JWT in the Authorization header
    const token = match[1];

    // Verify the JWT
    const decoded = jwt.verify(token, JWT_SECRET);
    if (!decoded) {
        return access.unauthorized();
    }

    // Return the user ID from the JWT
    return access.authorized();
};
```

Here's an example of how to use `jose` to verify a token using a JWKS endpoint exposed by authentication providers:

```typescript
import { jwtVerify, createRemoteJWKSet } from 'jose';

const JWKS = createRemoteJWKSet(new URL('https://{YOUR_AUTH_PROVIDER}/.well-known/jwks.json'));

export async function authenticate({ request, access }) {
    // We check for a token in the Authorization header, and
    // do a database lookup based on this.
    const auth = request.header('Authorization');

    const match = /^Bearer (\w+)$/.exec(auth);
    if(match == null) {
       return access.unauthorized();
    }

    // JWT in the Authorization header
    const token = match[1];

    try {
        // Verify the JWT
        const { payload } = await jwtVerify(token, JWKS);
        return access.authorized();
    } catch (error) {
        // If the token is invalid, return an unauthorized response
        return access.unauthorized();
    }
}
```

### Other Considerations

If you need more data validations before persisting data to the source database, consider introducing schema validation of the data being written to the source MongoDB database. 
You should use a [purpose-built](https://json-schema.org/tools?query=&sortBy=name&sortOrder=ascending&groupBy=toolingTypes&licenses=&languages=&drafts=&toolingTypes=&environments=&showObsolete=false) library for this, and use [MongoDB Schema Validation](https://www.mongodb.com/docs/manual/core/schema-validation/) to enforce the types in the database.

Please [contact us](/resources/contact-us) for assistance on any of the above.

