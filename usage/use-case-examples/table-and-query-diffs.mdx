---
title: 'Table and Query Diffs'
description: 'Get exact changes for query results or individual tables in JavaScript'
---

# Overview

While [basic/incremental watch queries](/usage/use-case-examples/watch-queries) enable reactive UIs by notifying you of query result changes and providing updated result sets, they don't specify which individual rows were modified. For cases where you need to know precisely which rows were added, updated, or removed, PowerSync offers two options:

1. **Differential watch queries** work with any SQL query, including joins across multiple tables. On each dependent-table change, PowerSync re-runs the query, compares it to the previous result, and reports added/updated/removed rows. This is very flexible and ideal for precise UI updates. Trade‑off: for large result sets it still fetches and scans them to find small changes (e.g., scanning ~1,000 rows to detect 1 new item).

2. **Trigger-based table diffs** record row‑level INSERT/UPDATE/DELETE operations for a single table into a temporary SQLite table via triggers. These diff records are written at the moment writes happen, so later reads don’t need to scan the full dataset. This keeps the per‑update cost proportional to the number of affected rows, at the cost of some write overhead and the single‑table scope.

<Note>
  **JavaScript Only**: Differential watch queries and trigger-based table diffs are currently only available in the JavaScript SDKs starting from:
  * Web v1.25.0 (differential queries) and v1.26.0 (trigger-based diffs)
  * React Native v1.23.1 (differential queries) and v1.24.0 (trigger-based diffs)
  * Node.js v0.8.1 (differential queries) and v0.9.0 (trigger-based diffs)
</Note>

## Key differences

- **Scope**: Differential watches work for arbitrary query results (including joins). Trigger-based diffs track row-level changes on a single table.
- **Overhead**: Differential watches re-query and compare result sets on each change (overhead grows with result set size). Trigger-based diffs do per-row work at write time (overhead grows with number of affected rows).
- **Processing path**: Differential watches run on read connections and re-query/compare results on each change (often concurrent on some platforms). Trigger-based diffs record changes at write time and require a `writeLock` during processing (only a single `writeLock` is allowed).
- **Storage/shape**: Trigger-based diffs store changes as rows in a temporary SQLite table that you can query with SQL. Differential watch diffs are exposed to app code as JS objects/arrays.
- **Filtering**: Differential watches query the SQLite DB on any change to the query's dependent tables, and the changes are filtered after querying SQLite. Trigger-based diffs can filter/skip storing diff records inside the SQLite trigger, which prevents emissions on a lower level.


## When to choose which

- Differential watch queries: Best for arbitrary (including multi‑table) queries and small–moderate result sets. Fewer limitations overall, but less efficient on very large results.

- Trigger-based table diffs (experimental): Best when you want per‑row updates on one table and to process only changed rows. Requires a `writeLock` during processing and adds some write overhead.

# Differential Watch Queries 

Differential watch queries return structured diffs of query results (added/updated/removed rows) and preserve references for unchanged items, enabling precise UI updates. See the full guide and more examples in [Live Queries / Watch Queries → Differential Watch Queries](/usage/use-case-examples/watch-queries#differential-watch-queries).

## Common use cases
- Incremental UI updates (lists, data grids, tables): Update only changed items; unchanged rows keep references for memoized/virtualized UIs.
- Collaborative editing (Yjs): Use diffs instead of tracking seen rows; example provider [here](https://github.com/powersync-ja/powersync-js/blob/33e6051a773c392959fc802ed90e892a9c9a1d59/demos/yjs-react-supabase-text-collab/src/library/powersync/PowerSyncYjsProvider.ts#L53).

## Basic usage:

```javascript
// JavaScript / React Native / Node.js
const lists = db
  .query({ sql: 'SELECT * FROM lists WHERE state = ?', parameters: ['pending'] })
  .differentialWatch();

const dispose = lists.registerListener({
  onDiff: (diff) => {
    // diff.added, diff.updated, diff.removed
  }
});
```

# Trigger-Based Table Diffs (experimental)

Trigger-based diffs use temporary SQLite triggers plus a temporary table to record row-level operations as they happen. This enables efficient downstream processing inside SQLite or in app code.

<Note>
This API is experimental and may change. It currently targets JavaScript SDKs.
</Note>

## Creating a diff trigger

Set up temporary triggers that write change operations into a temporary table you control:

```javascript
// Define the temporary table to store the diff
const tempTable = 'listsDiff';

// Configure triggers to record INSERT and UPDATE operations on `lists`
const dispose = await db.triggers.createDiffTrigger({
  source: 'lists',
  destination: tempTable,
  columns: ['name'], // track only if these columns change (optional)
  // when: "json_extract(NEW.data, '$.project_id') = ?", // optional SQL filter
  // parameters: ['abc'], // optional parameters for the WHEN clause
  operations: [DiffTriggerOperation.INSERT, DiffTriggerOperation.UPDATE]
});

// ... perform writes on `lists` ...

// Consume and clear changes within a writeLock
await db.writeLock(async (tx) => {
  const changes = await tx.getAll(/* sql */ `
    SELECT * FROM ${tempTable}
  `);

  // Process changes here

  // Clear after processing
  await tx.execute(/* sql */ `DELETE FROM ${tempTable};`);
});

// Later, clean up triggers and temp table
await dispose();
```

## Tracking and reacting to changes

A more convenient `trackTableDiff` method uses `createDiffTrigger` internally to track table changes, but adds additional logic to automatically consume and process the changes as they occur. This eliminates the need to manually manage the temporary table and write locks.

The example below uses triggers to process todo records as they are inserted into the database:

```javascript
const stop = await db.triggers.trackTableDiff({
  source: 'todos',
  columns: ['list_id'],
  operations: [DiffTriggerOperation.INSERT],
  when: { [DiffTriggerOperation.INSERT]: `json_extract(NEW.data, '$.list_id') = ?` },
  parameters: { [DiffTriggerOperation.INSERT]: [firstList.id] },
  onChange: async (context) => {
    // Join against the DIFF table provided by the context
    const newTodos = await context.getAll(/* sql */ `
      SELECT todos.*
      FROM DIFF
      JOIN todos ON DIFF.id = todos.id
    `);

    // Handle new todos here
  }
});

// Later
await stop();
```

 

