---
title: "Sync Streams"
description: Sync Streams enable partial sync, letting you define exactly which data from your backend syncs to each client using simple SQL-like queries.
sidebarTitle: "Quickstart"
---

import StreamDefinitionReference from '/snippets/stream-definition-reference.mdx';

Sync Streams enable partial sync — instead of syncing entire tables, you tell PowerSync exactly which data each user should have on their device. You write simple SQL-like queries to define the data, and your client app subscribes to the streams it needs. PowerSync handles the rest, keeping data in sync in real-time and making it available offline.

For example, you might create a stream that syncs only the current user's todo items, another for shared projects they have access to, and another for reference data that everyone needs. Your app subscribes to these streams on demand, and only that data syncs to the client's local SQLite database.

<Note>
**Beta Release**

Sync Streams are now in beta and production-ready. We recommend Sync Streams for all new projects, and encourage existing projects to [migrate from Sync Rules](/sync/streams/migration).

We welcome your feedback — please share with us in [Discord](https://discord.gg/powersync).
</Note>

## Defining Streams

Streams are defined in a YAML configuration file. Each stream has a **name** and a **query** that specifies which rows to sync using SQL-like syntax. The query can reference parameters like the authenticated user's ID to personalize what each user receives.

<Tabs>
<Tab title="PowerSync Cloud">
In the [PowerSync Dashboard](https://dashboard.powersync.com/):

1. Select your project and instance
2. Go to the **Sync Streams** view
3. Edit the YAML directly in the dashboard
4. Click **Deploy** to validate and deploy

```yaml
config:
  edition: 2

streams:
  todos:
    query: SELECT * FROM todos WHERE owner_id = auth.user_id()
```
</Tab>

<Tab title="Self-Hosted">
Add a `sync_config` section to your `config.yaml`:

```yaml config.yaml
sync_config:
  content: |
    config:
      edition: 2

    streams:
      todos:
        query: SELECT * FROM todos WHERE owner_id = auth.user_id()
```
</Tab>
</Tabs>

Available stream options:

<StreamDefinitionReference />

## Basic Examples

There are two independent concepts to understand:

- **Data scope**: What data the stream returns
  - *Global data*: No parameters, same data for all users (e.g. reference tables like categories)
  - *User-scoped data*: Uses `auth.user_id()` or JWT claims, different per user
  - *Parameterized data*: Uses `subscription.parameter()`, varies based on what the client subscribes to

- **Subscription behavior**: When the client syncs the data
  - *Auto-subscribe*: Client automatically subscribes on connect (`auto_subscribe: true`)
  - *On-demand*: Client explicitly subscribes when needed (default behavior)

### Global Data

Data without parameters is "global" data, meaning the same data goes to all users. This is useful for reference tables:

```yaml
config:
  edition: 2

streams:
  # Same categories for everyone
  categories:
    query: SELECT * FROM categories

  # Same active products for everyone
  products:
    query: SELECT * FROM products WHERE active = true
```

<Note>
Global data streams still require clients to subscribe explicitly unless you set `auto_subscribe: true`.
</Note>

### User-Scoped Data

Use `auth.user_id()` or JWT claims to return different data per user:

```yaml
config:
  edition: 2

streams:
  # Each user gets their own lists
  my_lists:
    query: SELECT * FROM lists WHERE owner_id = auth.user_id()

  # Each user gets their own orders
  my_orders:
    query: SELECT * FROM orders WHERE user_id = auth.user_id()
```

### Parameterized Data (On-Demand)

Use `subscription.parameter()` for data that clients subscribe to explicitly:

```yaml
config:
  edition: 2

streams:
  # Sync todos for a specific list when the client subscribes with a list_id
  list_todos:
    query: |
      SELECT * FROM todos 
      WHERE list_id = subscription.parameter('list_id')
        AND list_id IN (SELECT id FROM lists WHERE owner_id = auth.user_id())
```

### Using Auto-Subscribe

Set `auto_subscribe: true` to sync data automatically when clients connect. This is useful for:
- Reference data that all screens need
- User data that should always be available offline
- Maintaining [Sync Rules](/sync/rules/overview) behavior (sync everything upfront) during migration

```yaml
config:
  edition: 2

streams:
  # Global data, synced automatically
  categories:
    query: SELECT * FROM categories
    auto_subscribe: true

  # User-scoped data, synced automatically
  my_orders:
    query: SELECT * FROM orders WHERE user_id = auth.user_id()
    auto_subscribe: true

  # Parameterized data, subscribed on-demand (no auto_subscribe)
  order_items:
    query: |
      SELECT * FROM order_items 
      WHERE order_id = subscription.parameter('order_id')
        AND order_id IN (SELECT id FROM orders WHERE user_id = auth.user_id())
```

## Using Parameters

Parameters let you filter data dynamically. The two most common types are:

**Auth parameters** filter by user identity. Use `auth.user_id()` to sync data belonging to the current user:

```yaml
streams:
  my_lists:
    query: SELECT * FROM lists WHERE owner_id = auth.user_id()
```

**Subscription parameters** are passed from the client when subscribing. Use these for on-demand data:

```yaml
streams:
  list_todos:
    query: SELECT * FROM todos WHERE list_id = subscription.parameter('list_id')
```

```js
// Client subscribes with the list they want to view
const sub = await db.syncStream('list_todos', { list_id: 'abc123' }).subscribe();
```

See [Using Parameters](/sync/streams/parameters) for the full reference on subscription, auth, and connection parameters.

## Client-Side Usage

Subscribe to streams from your client app:

<Tabs>
<Tab title="JS">
```js
const sub = await db.syncStream('list_todos', { list_id: 'abc123' })
  .subscribe({ ttl: 3600 });

// Wait for this subscription to have synced
await sub.waitForFirstSync();

// When the component needing the subscription is no longer active...
sub.unsubscribe();
```

**React hooks:**

```jsx
const stream = useSyncStream({ name: 'list_todos', parameters: { list_id: 'abc123' } });
// Check download progress or subscription information
stream?.progress;
stream?.subscription.hasSynced;
```

The `useQuery` hook can wait for Sync Streams before running queries:

```jsx
const { data } = useQuery(
  'SELECT * FROM todos WHERE list_id = ?',
  [listId],
  { streams: [{ name: 'list_todos', parameters: { list_id: listId }, waitForStream: true }] }
);
```
</Tab>

<Tab title="Dart">
```dart
final sub = await db
  .syncStream('list_todos', {'list_id': 'abc123'})
  .subscribe(ttl: const Duration(hours: 1));

// Wait for this subscription to have synced
await sub.waitForFirstSync();

// When the component needing the subscription is no longer active...
sub.unsubscribe();
```
</Tab>

<Tab title="Kotlin">
```kotlin
val sub = database.syncStream("list_todos", mapOf("list_id" to JsonParam.String("abc123")))
  .subscribe(ttl = 1.0.hours)

// Wait for this subscription to have synced
sub.waitForFirstSync()

// When the component needing the subscription is no longer active...
sub.unsubscribe()
```

**Compose:**

```kotlin
@Composable
fun TodoListPage(db: PowerSyncDatabase, listId: String) {
  val stream = db.composeSyncStream(
    name = "list_todos", 
    parameters = mapOf("list_id" to JsonParam.String(listId))
  )
  // Define component based on stream state
}
```
</Tab>

<Tab title="Swift">
```swift
let sub = try await db.syncStream("list_todos", ["list_id": "abc123"])
  .subscribe(ttl: .hours(1))

// Wait for this subscription to have synced
try await sub.waitForFirstSync()

// When the component needing the subscription is no longer active...
sub.unsubscribe()
```
</Tab>

<Tab title=".NET">
```csharp
var sub = await db.SyncStream("list_todos", new() { ["list_id"] = "abc123" })
  .Subscribe(new SyncStreamSubscribeOptions { Ttl = TimeSpan.FromHours(1) });

// Wait for this subscription to have synced
await sub.WaitForFirstSync();

// When the component needing the subscription is no longer active...
sub.Unsubscribe();
```
</Tab>
</Tabs>

### TTL (Time-To-Live)

Each subscription has a `ttl` that keeps data cached after unsubscribing. This enables warm cache behavior — when users return to a screen, data is already available. Default TTL is 24 hours. See [Client-Side Usage](/sync/streams/client-usage) for details.

```js
// Set TTL in seconds when subscribing
const sub = await db.syncStream('todos', { list_id: 'abc' })
  .subscribe({ ttl: 3600 }); // Cache for 1 hour after unsubscribe
```
## Developer Notes

- **SQL Syntax**: Stream queries use a SQL-like syntax with `SELECT` statements. You can use subqueries, `INNER JOIN`, and [CTEs](/sync/streams/ctes) for filtering. `GROUP BY`, `ORDER BY`, and `LIMIT` are not supported. See [Writing Stream Queries](/sync/streams/queries) for details on joins, multiple queries per stream, and other features.

- **Type Conversion**: Data types from your source database (Postgres, MongoDB, MySQL, SQL Server) are converted when synced to the client's SQLite database. Most types become `text`, so you may need to parse or cast values in your app code. See [Type Mapping](/sync/types) for details on how each type is handled.

- **Primary Key**: PowerSync requires every synced table to have a primary key column named `id` of type `text`. If your backend uses a different column name or type, you'll need to map it. For MongoDB, the `_id` field automatically maps to `id`. See [Client ID](/sync/advanced/client-id) for setup instructions.

- **Case Sensitivity**: To avoid issues across different databases and platforms, use **lowercase identifiers** for all table and column names in your Sync Streams. If your backend uses mixed case, see [Case Sensitivity](/sync/advanced/case-sensitivity) for how to handle it.

- **Bucket Limits**: PowerSync uses internal partitions called "buckets" to efficiently sync data. There's a limit of 1,000 buckets per user. Each unique combination of a stream and its parameters creates one bucket, so keep this in mind when designing streams that use subscription parameters. You can use [multiple queries per stream](/sync/streams/queries#multiple-queries-per-stream) to reduce bucket count. See [Buckets](/architecture/powersync-service#bucket-system) for background on this.

- **Troubleshooting**: If data isn't syncing as expected, the [Sync Diagnostics Client](/tools/diagnostics-client) helps you inspect what's happening for a specific user — you can see which buckets the user has and what data is being synced.

## Examples & Demos

See [Examples & Demos](/sync/streams/examples) for working demo apps and complete application patterns.

## Migrating from Sync Rules

If you have an existing project using Sync Rules, see the [Migration Guide](/sync/streams/migration) for step-by-step instructions, syntax changes, and examples.
