---
title: "Live Queries / Watch Queries"
description: "Subscribe to real-time data changes with reactive live queries"
---

Live queries, also known as watch queries, are essential for building reactive apps where the UI automatically updates when the underlying data changes. PowerSync's watch functionality allows you to subscribe to SQL query results and receive updates whenever the dependent tables are modified.

- todo: link to this page from relevant sections in SDK references

# Overview

PowerSync provides multiple approaches to watching queries, each designed for different use cases and performance requirements:

1. **Basic Watch Queries** - These queries work across all SDKs, providing real-time updates when dependent tables change
2. **Comparison Watch Queries** - Only emit updates when data actually changes, preventing unnecessary re-renders
3. **Differential Watch Queries** - Provide detailed information about what specifically changed between result sets

Choose the approach that best fits your platform and performance needs.

# Basic Watch Queries by Platform

PowerSync supports the following basic watch queries based on your platform. These APIs return query results whenever the underlying tables change and are available across all SDKs for backwards compatibility.

<Tabs>
<Tab title="JavaScript/React Native/Node.js (AsyncIterator Approach)">

The original watch method using AsyncIterator pattern. This is the foundational watch API that works across all JavaScript environments and is being maintained for backwards compatibility. 

```javascript
async function* pendingLists(): AsyncIterable<string[]> {
  for await (const result of db.watch(
    `SELECT * FROM lists WHERE state = ?`,
    ['pending']
  )) {
    yield result.rows?._array ?? [];
  }
}
```

</Tab>
<Tab title="JavaScript/React Native/Node.js (Callback Approach)">

The callback-based watch method that doesn't require AsyncIterator polyfills. Use this approach when you need React Native compatibility or prefer synchronous method signatures:

```javascript
const pendingLists = (onResult: (lists: any[]) => void): void => {
  db.watch(
    'SELECT * FROM lists WHERE state = ?',
    ['pending'],
    {
      onResult: (result: any) => {
        onResult(result.rows?._array ?? []);
      }
    }
  );
}
```

</Tab>
<Tab title="React Hook">

React hook that combines watch functionality with built-in loading, fetching, and error states. Use this when you need convenient state management without React Suspense:

```javascript
const { data: pendingLists, isLoading, isFetching, error } = useQuery(
  'SELECT * FROM lists WHERE state = ?', 
  ['pending']
);
```

</Tab>
<Tab title="React Suspense">

React Suspense-based hook that automatically handles loading and error states through Suspense boundaries. Use this when you want to leverage React's concurrent features and avoid manual state handling:

```javascript
const { data: pendingLists } = useSuspenseQuery(
  'SELECT * FROM lists WHERE state = ?', 
  ['pending']
);
```

</Tab>
<Tab title="Vue Hook">

Vue composition API hook with built-in loading, fetching, and error states. Use this for reactive watch queries in Vue applications:

```javascript
const { data: pendingLists, isLoading, isFetching, error } = useQuery(
  'SELECT * FROM lists WHERE state = ?', 
  ['pending']
);
```

</Tab>
<Tab title="Dart/Flutter">

todo

</Tab>
<Tab title="Kotlin">

todo

</Tab>
<Tab title="Swift">

todo

</Tab>
<Tab title=".NET">

todo

</Tab>
</Tabs>

# JavaScript SDKs: Incremental Watch Queries

Basic watch queries can cause performance issues in UI frameworks like React because they return new arrays and objects on every dependent table change, even when the actual data hasn't changed. This can lead to excessive re-renders as components receive new props unnecessarily.

Incremental watch queries address this problem by comparing result sets using configurable comparators and only emitting updates when the comparison detects actual data changes. Differential watch queries additionally preserve object references for unchanged items and provide detailed diff information (added/removed/updated items) to enable granular UI updates.

<Info>
**JavaScript Only**: Incremental watch queries are currently available only in the JavaScript SDKs. 
</Info>

## The `WatchedQuery` Class

All incremental queries use the new `WatchedQuery` class 
- The logic required for incrementally watched queries requires additional computation and introduces additional complexity to the implementation. For these reasons a new concept of a `WatchedQuery` class is introduced, along with a new `query` method allows building a instances of `WatchedQuery`s via `watch` and `differentialWatch` methods.
- New `updateSettings` API, see below.

Provides advanced features:
- Automatically reprocesses itself if the PowerSync schema has been updated with `updateSchema`.
- Automatically closes itself when the PowerSync client has been closed.
- Allows for the query parameters to be updated after instantiation.
- Allows shared listening to state changes.

## 1. Comparison Watch Queries
Comparison based queries behave similar to basic watched queries. These queries still query the SQLite DB under the hood on each dependant table change, but they compare the result set and only incrementally yield results if a change has been made. The latest query result is yielded as the result set.

<Tabs>
<Tab title="Existing AsyncIterator Approach">

Existing AsyncIterator API with configurable comparator that compares current and previous result sets, only yielding when the comparator detects changes. Use this across all SDKs to avoid re-renders from unchanged data while maintaining the familiar AsyncIterator pattern:

```javascript
async function* pendingLists(): AsyncIterable<string[]> {
  for await (const result of powerSync.watch('SELECT * FROM lists WHERE state = ?', ['pending'], {
    comparator: {
      checkEquality: (current, previous) => JSON.stringify(current) === JSON.stringify(previous)
    }
  })) {
    yield result.rows?._array ?? [];
  }
}
```

</Tab>
<Tab title="Existing Callback Approach">

Existing Callback API with configurable comparator that compares result sets and only invokes the callback when changes are detected. Use this when you need React Native compatibility or prefer callbacks while avoiding callback execution on unchanged data:

```javascript
const pendingLists = (onResult: (lists: any[]) => void): void => {
  powerSync.watch(
    'SELECT * FROM lists WHERE state = ?',
    ['pending'],
    {
      onResult: (result: any) => {
        onResult(result.rows?._array ?? []);
      }
    },
    {
      comparator: {
        checkEquality: (current, previous) => {
          // This comparator will only report updates if the data changes.
          return JSON.stringify(current) === JSON.stringify(previous);
        }
      }
    }
  );
}
```

</Tab>
<Tab title="WatchedQuery Default">

WatchedQuery class that supports multiple listeners via registerListener(), automatic cleanup on PowerSync close, and updateSettings() for dynamic parameter changes. Use this as the preferred approach for JavaScript SDKs when you need query sharing, multiple subscribers, or dynamic query modification:

```javascript
// Create an instance of a WatchedQuery
const pendingLists = db.query({
  sql: 'SELECT * FROM lists WHERE state = ?',
  parameters: ['pending']
}).watch();

// The registerListener method can be used multiple times to listen for updates
const dispose = pendingLists.registerListener({
  onData: (data) => {
    // This callback will be called whenever the data changes
    console.log('Data updated:', data);
  },
  onStateChange: (state) => {
    // This callback will be called whenever the state changes
    // The state contains metadata about the query, such as isFetching, isLoading, etc.
    console.log('State changed:', state.error, state.isFetching, state.isLoading, state.data);
  },
  onError: (error) => {
    // This callback will be called if the query fails
    console.error('Query error:', error);
  }
});
```

</Tab>
<Tab title="WatchedQuery with Incremental Updates">

WatchedQuery class with configurable comparator that compares result sets before emitting to listeners, preventing unnecessary listener invocations when data hasn't changed. Use this when you want shared query instances plus result set comparison to minimize processing overhead:

```javascript
// Create an instance of a WatchedQuery
const pendingLists = powerSync.query({
  sql: 'SELECT * FROM lists WHERE state = ?',
  parameters: ['pending'],
}).watch({
  comparator: {
    checkEquality: (current, previous) => {
      // This comparator will only report updates if the data changes.
      return JSON.stringify(current) === JSON.stringify(previous);
    }
  }
});

// Register listeners as before...
```

</Tab>
<Tab title="React useQuery">

React hook that uses comparators to detect changes at the item level, only triggering re-renders when individual items are added, removed, or modified. Use this when you want built-in state management plus incremental updates for React components:

```javascript
const { data: pendingLists, isLoading, isFetching, error } = useQuery(
  'SELECT * FROM lists WHERE state = ?', 
  ['pending'], 
  {
    comparator: {
      keyBy: (item) => item.id,
      compareBy: (item) => JSON.stringify(item)
    }
  }
);
```

</Tab>
<Tab title="React useSuspenseQuery">

React Suspense hook that preserves object references for unchanged items and uses item-level comparators to minimize re-renders. Use this when you want concurrent React features, automatic state handling, and memoization-friendly object stability:

```javascript
const { data: lists } = useSuspenseQuery(
  'SELECT * FROM lists WHERE state = ?', 
  ['pending'], 
  {
    comparator: {
      keyBy: (item) => item.id,
      compareBy: (item) => JSON.stringify(item)
    }
  }
);
```

</Tab>

</Tabs>

- todo recommendation from Steven: Efficiently using React Memoization for the widgets. This one is a bit indirect, but the incrementally watched queries have much less benefit without this.

## 2. Differential Watch Queries
Differential queries watch a SQL query and report detailed information on the changes between result sets. This gives additional information such as the added, removed, updated rows between result set changes.

Computes and reports precise diffs between result sets (added/removed/updated items) while preserving object references for unchanged items, enabling more granular UI updates. Use differential watch when you need to update only specific list items, implement optimistic UI updates, or minimize DOM manipulation by knowing exactly which items changed:

```javascript
// Create an instance of a WatchedQuery
const pendingLists = powerSync.query({
  sql: 'SELECT * FROM lists WHERE state = ?',
  parameters: ['pending']
}).differentialWatch();

// The registerListener method can be used multiple times to listen for updates
const dispose = pendingLists.registerListener({
  onData: (data) => {
    // This callback will be called whenever the data changes
    console.log('Data updated:', data);
  },
  onStateChange: (state) => {
    // This callback will be called whenever the state changes
    // The state contains metadata about the query, such as isFetching, isLoading, etc.
    console.log('State changed:', state.error, state.isFetching, state.isLoading, state.data);
  },
  onError: (error) => {
    // This callback will be called if the query fails
    console.error('Query error:', error);
  },
  onDiff: (diff) => {
   // This callback will be called whenever the data changes.
    console.log('Data updated:', diff.added, diff.updated);
  }
});
```

todo recommendation from Steven: document optimisations for the differentiator methods. This depends on the table and query structure.

<Note>
- See a demo of the differential stuff in the updated YJS demo app
    - Document updates are watched via a differential incremental query. New updates are passed to YJS for consolidation as they are synced.
</Note>

### Query Sharing
`WatchedQuery` instances can be shared across components:
```javascript
// Create a shared query instance 
const sharedTodosQuery = db
  .query({ sql: 'SELECT * FROM todos WHERE list_id = ?', parameters: [listId] })
  .watch();

// Multiple components can listen to the same query
const dispose1 = sharedTodosQuery.registerListener({ 
  onData: (data) => updateTodosList(data) 
});

const dispose2 = sharedTodosQuery.registerListener({ 
  onData: (data) => updateTodosCount(data.length) 
});
```

### React Hook for External WatchedQuery Instances

When you need to share query instances across components or manage their lifecycle independently from component mounting, use the `useWatchedQuerySubscription` hook. This is ideal for global state management, query caching, or when multiple components need to subscribe to the same data:

```javascript
// Managing the WatchedQuery externally can extend its lifecycle and allow in-memory caching between components.
const pendingLists = db.query({
  sql: 'SELECT * FROM lists WHERE state = ?',
  parameters: ['pending']
}).watch();

// In the component
export const MyComponent = () => {
  // In React one could import the `pendingLists` query or create a context provider for various queries
  const { data } = useWatchedQuerySubscription(pendingLists);
  
  return (
    <div>
      {data.map(item => <div key={item.id}>{item.name}</div>)}
    </div>
  );
}
```

### Dynamic Parameter Updates
Update query parameters to affect all subscribers:
```javascript
// Updates to query parameters can be performed in a single place, affecting all subscribers
watch.updateSettings({
  query: new GetAllQuery({ sql: `SELECT * FROM todos OFFSET ? LIMIT 100`, parameters: [newOffset] })
});
```