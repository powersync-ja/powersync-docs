---
title: 'Table and Query Diffs'
description: 'Get exact changes for query results or individual tables in JavaScript'
---

# Overview

While [basic/incremental watch queries](/usage/use-case-examples/watch-queries) enable reactive UIs by notifying you of query result changes and providing updated result sets, they don't specify which individual rows were modified. For cases where you need to know precisely which rows were added, updated, or removed, PowerSync offers two options:

1. **Differential watch queries** work with any SQL query, including joins across multiple tables. On each dependent-table change, PowerSync re-runs the query, compares it to the previous result, and reports added/updated/removed rows. This is very flexible and ideal for precise UI updates. Trade‑off: for large result sets it still fetches and scans them to find small changes (e.g., scanning ~1,000 rows to detect 1 new item).

2. **Trigger-based table diffs** record row‑level INSERT/UPDATE/DELETE operations for a single table into a temporary SQLite table via triggers. These diff records are written at the moment writes happen, so later reads don’t need to scan the full dataset. This keeps the per‑update cost proportional to the number of affected rows, at the cost of some write overhead and the single‑table scope.

<Note>
  **JavaScript Only**: Differential watch queries and trigger-based table diffs are currently only available in the JavaScript SDKs starting from:
  * Web v1.25.0 (differential queries) and v1.26.0 (trigger-based diffs)
  * React Native v1.23.1 (differential queries) and v1.24.0 (trigger-based diffs)
  * Node.js v0.8.1 (differential queries) and v0.9.0 (trigger-based diffs)
</Note>

## Key differences

- **Scope**: Differential watches work for arbitrary query results (including joins). Trigger-based diffs track row-level changes on a single table.
- **Overhead**: Differential watches re-query and compare result sets on each change (overhead grows with result set size). Trigger-based diffs do per-row work at write time (overhead grows with number of affected rows).
- **Processing path**: Differential watches run on read connections and re-query/compare results on each change (often concurrent on some platforms). Trigger-based diffs record changes at write time and require a `writeLock` during processing (only a single `writeLock` is allowed).
- **Storage/shape**: Trigger-based diffs store changes as rows in a temporary SQLite table that you can query with SQL. Differential watch diffs are exposed to app code as JS objects/arrays.
- **Filtering**: Differential watches query the SQLite DB on any change to the query's dependent tables, and the changes are filtered after querying SQLite. Trigger-based diffs can filter/skip storing diff records inside the SQLite trigger, which prevents emissions on a lower level.


## When to choose which

- Differential watch queries: Best for arbitrary (including multi‑table) queries and small to moderate result sets. This API has fewer limitations overall, but is less efficient on very large results.
- Trigger-based table diffs (experimental): Best when you need per‑row updates on one table and to process only changed rows. Requires a `writeLock` during processing and adds some write overhead.

# Differential Watch Queries 

Differential watch queries return structured diffs of query results (added/updated/removed rows) and preserve references for unchanged items, enabling precise UI updates. See the full guide and more examples in [Live Queries / Watch Queries → Differential Watch Queries](/usage/use-case-examples/watch-queries#differential-watch-queries).

## Common use cases
- Incremental UI updates (lists, data grids, tables): Update only changed items; unchanged rows keep references for memoized/virtualized UIs.
- Collaborative editing (Yjs): Use diffs instead of tracking seen rows; example provider [here](https://github.com/powersync-ja/powersync-js/blob/33e6051a773c392959fc802ed90e892a9c9a1d59/demos/yjs-react-supabase-text-collab/src/library/powersync/PowerSyncYjsProvider.ts#L53).

## Basic usage:

```javascript
// JavaScript / React Native / Node.js
const lists = db
  .query({ sql: 'SELECT * FROM lists WHERE state = ?', parameters: ['pending'] })
  .differentialWatch();

const dispose = lists.registerListener({
  onDiff: (diff) => {
    // diff.added, diff.updated, diff.removed
  }
});
```

# Trigger-Based Table Diffs (experimental)

Trigger-based diffs use temporary SQLite triggers plus a temporary table to record row-level operations as they happen. This enables efficient downstream processing inside SQLite or in app code.

<Warning>
The `db.triggers` APIs are experimental. We're actively seeking feedback on:

- API design and developer experience
- Additional features or optimizations needed

Join our [Discord community](https://discord.gg/powersync) to share your experience and get help.
</Warning>

## Tracking and reacting to changes (recommended)

The primary API is `trackTableDiff`. It wraps the lower-level trigger setup, automatically manages a `writeLock` during processing, exposes a `DIFF` table alias to join against, and cleans up when you call the returned `stop()` function. Think of it as an automatic "watch" that processes diffs as they occur.

```javascript
const stop = await db.triggers.trackTableDiff({
  source: 'todos',
  // Only record UPDATEs when these columns change; always record INSERT/DELETE
  columns: ['list_id'],
  // Select which operations to capture
  operations: [DiffTriggerOperation.INSERT],
  // Optional WHEN clause per operation to filter inside the trigger
  when: { [DiffTriggerOperation.INSERT]: `json_extract(NEW.data, '$.list_id') = ?` },
  // Parameters for the WHEN clause
  parameters: { [DiffTriggerOperation.INSERT]: [firstList.id] },
  // onChange runs under a writeLock to avoid race conditions
  onChange: async (context) => {
    const newTodos = await context.getAll(/* sql */ `
      SELECT todos.*
      FROM DIFF
      JOIN todos ON DIFF.id = todos.id
    `);

    // Handle new todos here
  }
});

// Later, dispose triggers and internal resources
await stop();
```

## Lower-level: createDiffTrigger (advanced)

Set up temporary triggers that write change operations into a temporary table you control. Prefer `trackTableDiff` unless you need to manage lifecycle and locking manually (e.g., buffer diffs and process them on a later user action without holding a `writeLock`).

```javascript
// Define the temporary table to store the diff
const tempTable = 'listsDiff';

// Configure triggers to record INSERT and UPDATE operations on `lists`
const dispose = await db.triggers.createDiffTrigger({
  source: 'lists',
  destination: tempTable,
  columns: ['name'], // track only if these columns change (optional)
  // when: "json_extract(NEW.data, '$.project_id') = ?", // optional SQL filter
  // parameters: ['abc'], // optional parameters for the WHEN clause
  operations: [DiffTriggerOperation.INSERT, DiffTriggerOperation.UPDATE]
});

// ... perform writes on `lists` ...

// Consume and clear changes within a writeLock
await db.writeLock(async (tx) => {
  const changes = await tx.getAll(/* sql */ `
    SELECT * FROM ${tempTable}
  `);

  // Process changes here

  // Clear after processing
  await tx.execute(/* sql */ `DELETE FROM ${tempTable};`);
});

// Later, clean up triggers and temp table
await dispose();
```

 

 

