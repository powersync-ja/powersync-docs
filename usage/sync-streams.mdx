---
title: "Sync Streams (Closed Alpha)"
description: Sync Streams will replace Sync Rules and are designed to allow for more dynamic syncing.
---

# Motivation

PowerSync's original [Sync Rules](/usage/sync-rules) system was designed for offline-first applications, where users need the entire dataset available to cater for offline scenarios. With Sync Rules, all data is synced upfront and being kept up-to-date in a consistent way.

However, in web apps you often want to sync only the data your users need for the current page. Your users may have multiple tabs open, each needing a different set of data.

[Client parameters](/usage/sync-rules/advanced-topics/client-parameters) in the current Sync Rules system partially support these use cases. You can use them to specify the data your users need (for example, a `project_ids` array). However, tracking and building these arrays in your client becomes difficult — especially when your users have multiple tabs open, each needing different data.

We are introducing Sync Streams to address the above. Key improvements in Sync Streams over Sync Rules are:

1. **On-demand sync**: You define multiple streams, and a user can subscribe to them one or more times with different parameters.
2. **Temporary caching-like behavior**: Each subscription includes a configurable `ttl` that keeps data active after your app unsubscribes, acting as a warm cache for recently accessed data.
3. **Simpler developer experience**: Simplified mental model, and capabilities such as your UI components automatically managing subscriptions (for example, React hooks).

## Alpha Release

Sync Streams will ultimately replace the current Sync Rules system. They are currently in a closed alpha release with a limited set of customers for validation and soak testing. We are actively seeking your feedback on how they perform for your use cases, the developer experience, missing capabilities, and potential optimizations.

Sync Streams will be supported alongside Sync Rules for the foreseeable future, although we recommend you migrate to Sync Streams once in Beta.

# Requirements for Using Sync Streams

* v1.15.0 of the Service (currently available on the `Next` channel)
* Minimum SDK versions:
  * JS: todo
  * Dart: todo
  * Kotlin: todo
  * Swift: Coming soon.
* Enable the [Rust-based sync client](https://releases.powersync.com/announcements/improved-sync-performance-in-our-client-sdks)
  <Expandable title=" instructions">
  <Tabs>
    <Tab title="JS">
        In JavaScript SDKs, enable the new implementation with the `clientImplementation` option when connecting:

        ```js
        await db.connect(new MyConnector(), {
            clientImplementation: SyncClientImplementation.RUST
        });
        ```

        You can migrate back to the JavaScript client later by removing the option.
    </Tab>
    <Tab title="Dart">
        Pass the `syncImplementation` option when connecting:

        ```dart
        database.connect(
            connector: YourConnector(),
            options: const SyncOptions(
                syncImplementation: SyncClientImplementation.rust,
            ),
        );
        ```

        You can migrate back to the Dart client later by removing the option.
    </Tab>
    <Tab title="Kotlin">
        Pass the `newClientImplementation` option when connecting:

        ```kotlin
        //@file:OptIn(ExperimentalPowerSyncAPI::class)
        database.connect(MyConnector(), options = SyncOptions(
            newClientImplementation = true,
        ))
        ```

        You can migrate back to the Kotlin client later by removing the option.
    </Tab>
    <Tab title="Swift">
        Pass the `newClientImplementation` option when connecting:

        ```swift
        @_spi(PowerSyncExperimental) import PowerSync

        try await db.connect(connector: connector, options: ConnectOptions(
            newClientImplementation: true,
        ))
        ```

        You can migrate back to the Swift client later by removing the option.
    </Tab>
  </Tabs>  
  </Expandable>
* Sync Streams are currently defined in the same .yaml file as Sync Rules: `sync_rules.yaml` (PowerSync Cloud) or `config.yaml` (Open Edition/self-hosted). To enable Sync Streams, add the following configuration:
  
  ```yaml
  config:
    edition: 2 # see https://github.com/powersync-ja/powersync-service/discussions/348

  streams:
    ... # see Stream Definition Syntax section below
  ```

# Stream Definition Syntax

You specify **stream definitions** similar to bucket definitions in Sync Rules. Your users then subscribe to the defined streams (through your app) one or more times, with different parameters.

Syntax:
```yaml sync_rules.yaml
streams:
  <stream_name>:
    query: string # similar to data queries in bucket definitions
    auto_subscribe: boolean # true to subscribe to this stream by default (similar to how Sync Rules work today), false (default) if clients should explicitly subscribe
    priority: number # bucket priority, same as in bucket definitions
    accept_potentially_dangerous_queries: boolean # silence warnings on dangerous queries, same as in bucket definitions
```

Basic example:
```yaml sync_rules.yaml
config:
  edition: 2
streams:
  issue: # Subscription to a specific issue
    query: select * from issues where id = subscription.parameters() ->> 'id' 
  issue_comments: # Subscription to a specific issue's comments
    query: select * from comments where issue_id = subscription.parameters() ->> 'id' 

```

Where Sync Rules' bucket definitions had separate parameter and data queries, Sync Streams use a single `query`. Instead of parameter queries, Sync Streams support a limited form of subqueries, for example:

```yaml sync_rules.yaml
# use auth and stream parameters directly in the query
select * from issues where id = stream.parameters() ->> 'id' and owner_id = auth.user_id()

# "in (subquery)" replaces parameter queries:
select * from comments where issue_id in (select id from issues where owner_id = auth.user_id())
```

Under the hood, Sync Streams use the same bucket system as Sync Rules, so you get the same functionality as before with parameter queries, while staying closer to plain SQL.

Accessing parameters is slightly different from bucket definitions:

```yaml sync_rules.yaml
subscription.parameters() -- all parameters for the specific subscription, as JSON
subscription.parameter('key') -- short-hand for getting a specific parameter
auth.jwt() -- JWT token payload, as JSON
auth.parameter('key') -- short-hand for getting a specific token payload parameter
auth.user_id() -- same as auth.parameter('sub')
connection.parameters() -- client parameters, as JSON
connection.parameter('key') -- short-hand for getting a specific client parameter
```

## Usage Examples

<Expandable title="Examples">

### Global data
Sync Rules:
```yaml sync_rules.yaml
  bucket_definitions:
    global:
        data:
        # Sync all todos
        - SELECT * FROM todos
        # Sync all lists except archived ones
        - SELECT * FROM lists WHERE archived = false
```
Sync Streams:

"Global" data — the data you want all of your users to have by default — is also defined as streams. Specify `auto_subscribe: true` so your users subscribe to them by default.
```yaml sync_rules.yaml
  streams:
    all_todos:
        query: SELECT * FROM todos
        auto_subscribe: true 
    unarchived_lists:
        query: SELECT * FROM lists WHERE archived = false
        auto_subscribe: true     

```

### A user's owned lists, with a priority
Sync Rules:
```yaml sync_rules.yaml
  bucket_definitions:
    user_lists:
        priority: 1 # See https://docs.powersync.com/usage/use-case-examples/prioritized-sync  
        parameters: SELECT request.user_id() as user_id
        data:
        - SELECT * FROM lists WHERE owner_id = bucket.user_id
```
Sync Streams:
```yaml sync_rules.yaml
  streams:
    user_lists:
        priority: 1 # See https://docs.powersync.com/usage/use-case-examples/prioritized-sync  
        query: SELECT * FROM lists WHERE owner_id = auth.user_id()
```

### Grouping by list_id
Sync Rules:
```yaml sync_rules.yaml
  bucket_definitions:
    owned_lists:
        parameters: |
            SELECT id as list_id FROM lists WHERE
            owner_id = request.user_id()
        data:
        - SELECT * FROM lists WHERE lists.id = bucket.list_id
        - SELECT * FROM todos WHERE todos.list_id = bucket.list_id
```
Sync Streams:
```yaml sync_rules.yaml
  streams:
    owned_lists:
        query: SELECT * FROM lists WHERE owner_id = auth.user_id()
    list_todos:
        query: SELECT * FROM todos WHERE list_id = subscription.parameter('list_id')
 
```

### Multiple parameters
Sync Rules:
```yaml sync_rules.yaml
  bucket_definitions:
    owned_org_lists:
        parameters: |
            SELECT id as list_id, org_id FROM lists WHERE
            owner_id = request.user_id()
        data:
        - SELECT * FROM lists WHERE lists.id = bucket.list_id and lists.org_id = bucket.org_id
        - SELECT * FROM todos WHERE todos.list_id = bucket.list_id and todos.org_id = bucket.org_id
```
Sync Streams:
```yaml sync_rules.yaml
  streams:
    owned_lists:
        query: SELECT * FROM lists WHERE owner_id = auth.user_id()
    list_org_todos:
        query: SELECT * FROM todos WHERE list_id = subscription.parameter('list_id') AND org_id = subscription.parameter('org_id')
```

### Client parameters
Sync Rules:
```yaml sync_rules.yaml
  bucket_definitions:
    posts:
        parameters: SELECT (request.parameters() ->> 'current_page') as page_number
        data:
        - SELECT * FROM posts WHERE page_number = bucket.page_number
```
Sync Streams:
```yaml sync_rules.yaml
  streams:
    posts:
        query: SELECT * FROM posts WHERE page_number = subscription.parameter('page_number')
```

### Specific columns/fields, renames and transformations

Selecting, renaming or transforming specific columns/fields is identical between Sync Rules and Sync Streams:

Sync Streams:
```yaml sync_rules.yaml
  streams:
    todos:
        # Select specific columns
        query: SELECT id, name, owner_id FROM todos 
        # Rename columns
        query: SELECT id, name, created_timestamp AS created_at FROM todos 
        # Cast number to text
        query: SELECT id, item_number :: text AS item_number FROM todos
        # Alternative syntax for the same cast
        query: id, CAST(item_number as TEXT) AS item_number FROM todos
        # Convert binary data (bytea) to base64
        query: id, base64(thumbnail) AS thumbnail_base64 FROM todos
        # Extract field from JSON or JSONB column
        query: id, metadata_json ->> 'description' AS description FROM todos
        # Convert time to epoch number
        query: id, unixepoch(created_at) AS created_at FROM todos
```
</Expandable>
# Client Side Syntax

In general, each SDK lets you:

* Use `db.syncStream(name, [params])` to get a `SyncStream` instance, then call `subscribe()`.
* Call `subscribe()` on a `SyncStream` to get a `SyncStreamSubscription`. This gives you access to `waitForFirstSync()` and `unsubscribe()`.
* Inspect `SyncStatus` for a list of `SyncSubscriptionDefinitions` describing all streams your app is subscribed to (either due to an explicit subscription or because the stream has `auto_subscribe: true`). It also reports per-stream download progress.
* Each sync stream has a `ttl` (time-to-live). After you call `unsubscribe()`, or when the page/app closes, the stream keeps syncing for the `ttl` duration, effectively acting as a cache. Each SDK lets you specify the `ttl`, or ignore the `ttl` and delete the data as soon as possible.

Select your language for specific examples:
<Tabs>
    <Tab title="JS">
    ```js
    const sub = await powerSync.syncStream('issues', {id: 'issue-id'}).subscribe(ttl: 3600);

    // Resolve current status for subscription
    const status = powerSync.currentStatus.forStream(sub);
    const progress = status?.progress;

    // Wait for this subscription to have synced
    await sub.waitForFirstSync();

    // When the component needing the subscription is no longer active...
    sub.unsubscribe();
    ```
    </Tab>
    <Tab title="Dart">
    ```dart
    final sub = await db
      .syncStream('issues', {'id': 'issue-id'})
      .subscribe(ttl: const Duration(hours: 1));

    // Resolve current status for subscription
    final status = db.currentStatus.forStream(sub);
    final progress = status?.progress;

    // Wait for this subscription to have synced
    await sub.waitForFirstSync();

    // When the component needing the subscription is no longer active...
    sub.unsubscribe();
    ```
    </Tab>
    <Tab title="Kotlin">
    ```Kotlin
    val sub = database.syncStream("issues", mapOf("id" to JsonParam.String("issue-id"))).subscribe(ttl = 1.0.hours);

    // Resolve current status for subscription
    val status = database.currentStatus.forStream(sub)
    val progress = status?.progress

    // Wait for this subscription to have synced
    sub.waitForFirstSync()

    // When the component needing the subscription is no longer active...
    sub.unsubscribe()
    ```
    </Tab>
    <Tab title="Swift - Coming soon">
        Coming soon
    </Tab>
</Tabs>


# Example Apps

We currently have a demo app available for Dart:

* You can try the [`supabase-todolist`](https://github.com/powersync-ja/powersync.dart/tree/main/demos/supabase-todolist) demo app, which we updated to use Sync Streams (Sync Rules are still supported).
* Use the following stream definitions:
  ```yaml sync_rules.yaml
    config:
      edition: 2
  streams:
  lists:
    query: SELECT * FROM lists
    auto_subscribe: true
  todos:
    query: SELECT * FROM todos WHERE list_id = subscription.parameter('list')
  ```
* In this example:
  * The app syncs lists by default (demonstrating existing Sync Rules / offline-first behavior).
  * The app syncs todos on demand when a user opens a list.
  * When the user navigates back to the same list, they won't see a loading state — demonstrating caching behavior.

Demos for our other SDKs will be released soon.