---
title: "Writing Queries"
description: Learn query syntax for filtering with subqueries and joins, selecting columns, and transforming data types.
sidebarTitle: "Writing Queries"
---

This page covers query syntax for Sync Streams: filtering, selecting columns, and transforming data. 

For parameter usage, see [Using Parameters](/sync/streams/parameters). For real-world patterns, see [Examples, Patterns & Demos](/sync/streams/examples).

## Basic Queries

The simplest stream query syncs all rows from a table:

```yaml
streams:
  categories:
    query: SELECT * FROM categories
```

Add a `WHERE` clause to filter:

```yaml
streams:
  active_products:
    query: SELECT * FROM products WHERE active = true
```

## Filtering by User

Most apps need to sync different data to different users. Use `auth.user_id()` to filter by the authenticated user:

```yaml
streams:
  my_lists:
    query: SELECT * FROM lists WHERE owner_id = auth.user_id()
```

This syncs only the lists owned by the current user. The user ID comes from the `sub` claim in their JWT token.

## On-Demand Data with Parameters

For data that should only sync when the user navigates to a specific screen, use subscription parameters. The client passes these when subscribing to a stream:

```yaml
streams:
  list_todos:
    query: SELECT * FROM todos WHERE list_id = subscription.parameter('list_id')
```

```js
// When user opens a specific list, subscribe with that list's ID
const sub = await db.syncStream('list_todos', { list_id: 'abc123' }).subscribe();
```

See [Using Parameters](/sync/streams/parameters) for the full reference on subscription, auth, and connection parameters.

## Selecting Columns

Select specific columns instead of `*` to reduce data transfer:

```yaml
streams:
  users:
    query: SELECT id, name, email, avatar_url FROM users WHERE org_id = auth.parameter('org_id')
```

### Renaming Columns

Use `AS` to rename columns in the synced data:

```yaml
streams:
  todos:
    query: SELECT id, name, created_timestamp AS created_at FROM todos
```

### Type Transformations

PowerSync syncs data to SQLite on the client. You may need to transform types for compatibility:

```yaml
streams:
  items:
    query: |
      SELECT 
        id,
        CAST(item_number AS TEXT) AS item_number,        -- Cast to text
        metadata_json ->> 'description' AS description,  -- Extract from JSON
        base64(thumbnail) AS thumbnail_base64,           -- Binary to base64
        unixepoch(created_at) AS created_at              -- DateTime to epoch
      FROM items
```

See [Type Mapping](/sync/types) for details on how each database type is handled.

## Using Subqueries

Subqueries let you filter based on related tables. Use `IN (SELECT ...)` to sync data where a foreign key matches rows in another table:

```yaml
streams:
  # Sync comments for issues owned by the current user
  my_issue_comments:
    query: |
      SELECT * FROM comments 
      WHERE issue_id IN (SELECT id FROM issues WHERE owner_id = auth.user_id())
```

### Nested Subqueries

Subqueries can be nested to traverse multiple levels of relationships. This is useful for normalized database schemas:

```yaml
streams:
  # Sync tasks for projects in organizations the user belongs to
  org_tasks:
    query: |
      SELECT * FROM tasks 
      WHERE project_id IN (
        SELECT id FROM projects WHERE org_id IN (
          SELECT org_id FROM org_members WHERE user_id = auth.user_id()
        )
      )
```

### Combining Parameters with Subqueries

A common pattern is using subscription parameters to select what data to sync, while using subqueries for authorization:

```yaml
streams:
  # User subscribes with a list_id, but can only see lists they own or that are shared with them
  list_items:
    query: |
      SELECT * FROM items 
      WHERE list_id = subscription.parameter('list_id')
        AND list_id IN (
          SELECT id FROM lists 
          WHERE owner_id = auth.user_id() 
             OR id IN (SELECT list_id FROM list_shares WHERE shared_with = auth.user_id())
        )
```

## Using Joins

For complex queries that traverse multiple tables, join syntax is often easier to read than nested subqueries. You can use `JOIN` or `INNER JOIN` (they're equivalent):

```yaml
streams:
  # Nested subquery version
  user_comments:
    query: |
      SELECT * FROM comments WHERE issue_id IN (
        SELECT id FROM issues WHERE project_id IN (
          SELECT project_id FROM project_members WHERE user_id = auth.user_id()
        )
      )
```

The same query using joins:

```yaml
streams:
  # Join version - same result, easier to read
  user_comments:
    query: |
      SELECT comments.* FROM comments
        INNER JOIN issues ON comments.issue_id = issues.id
        INNER JOIN project_members ON issues.project_id = project_members.project_id
      WHERE project_members.user_id = auth.user_id()
```

Both queries sync the same data. Choose whichever style is clearer for your use case.

### Multiple Joins

You can chain multiple joins to traverse complex relationships. This example joins four tables to sync checkpoints for assignments the user has access to:

```yaml
streams:
  my_checkpoints:
    query: |
      SELECT c.* FROM user_assignment_scope uas
        JOIN assignment a ON a.id = uas.assignment_id
        JOIN assignment_checkpoint ac ON ac.assignment_id = a.id
        JOIN checkpoint c ON c.id = ac.checkpoint_id
      WHERE uas.user_id = auth.user_id()
        AND a.active = true
```

### Self-Joins

You can join the same table multiple times using aliases. This is useful for finding related records through a shared relationship. For example, finding all users who share a group with the current user:

```yaml
streams:
  users_in_my_groups:
    query: |
      SELECT u.* FROM users u
        JOIN group_memberships gm1 ON u.id = gm1.user_id
        JOIN group_memberships gm2 ON gm1.group_id = gm2.group_id
      WHERE gm2.user_id = auth.user_id()
```

### Join Limitations

Sync Streams support a subset of join functionality:

- **Only inner joins**: Use `JOIN` or `INNER JOIN`. LEFT, RIGHT, and OUTER joins are not supported.
- **Single output table**: All selected columns must come from one table (use `table.*` or `table.column`)
- **Simple join conditions**: Join conditions must be equality comparisons like `table1.column = table2.column`
- **No `json_each` on joined columns**: Table-valued functions like `json_each` only work with auth/connection parameters, not with columns from joined tables.

```yaml
# Valid - selecting from one table
query: SELECT comments.* FROM comments JOIN issues ON comments.issue_id = issues.id

# Invalid - selecting from multiple tables
query: SELECT comments.*, issues.title FROM comments JOIN issues ON comments.issue_id = issues.id

# Invalid - complex join condition
query: SELECT * FROM a JOIN b ON a.x > b.y

# Invalid - json_each on joined column
query: |
  SELECT p.* FROM profile p
    JOIN project pr ON p.project_id = pr.id
  WHERE auth.user_id() IN (SELECT value FROM json_each(pr.allowed_users))
```

## Multiple Queries per Stream

You can group multiple queries into a single stream using `queries` instead of `query`. This is useful when several tables share the same access pattern:

```yaml
streams:
  user_data:
    queries:
      - SELECT * FROM notes WHERE owner_id = auth.user_id()
      - SELECT * FROM settings WHERE user_id = auth.user_id()
      - SELECT * FROM preferences WHERE user_id = auth.user_id()
    auto_subscribe: true
```

All three queries sync into the same bucket, which is more efficient than defining separate streams.

### When to Use Multiple Queries

Use `queries` when:
- Multiple tables have the same filtering logic (e.g., all filtered by `user_id`)
- You want to reduce the number of buckets
- Related data should sync together

```yaml
streams:
  # All project-related data syncs together
  project_details:
    queries:
      - SELECT * FROM tasks WHERE project_id = subscription.parameter('project_id')
      - SELECT * FROM files WHERE project_id = subscription.parameter('project_id')
      - SELECT * FROM comments WHERE project_id = subscription.parameter('project_id')
```

### Compatibility Requirements

For queries to share a bucket, they must use compatible parameter inputs. In practice, this means they should filter on the same parameters in the same way:

```yaml
# Valid - all queries use the same parameter pattern
streams:
  user_content:
    queries:
      - SELECT * FROM notes WHERE user_id = auth.user_id()
      - SELECT * FROM bookmarks WHERE user_id = auth.user_id()

# Valid - all queries use the same subscription parameter
streams:
  project_data:
    queries:
      - SELECT * FROM tasks WHERE project_id = subscription.parameter('project_id')
      - SELECT * FROM files WHERE project_id = subscription.parameter('project_id')
```

### Combining with CTEs

Multiple queries work well with [Common Table Expressions (CTEs)](/sync/streams/ctes) to share both the filtering logic and the bucket:

```yaml
streams:
  org_data:
    with:
      user_orgs: SELECT org_id FROM org_members WHERE user_id = auth.user_id()
    queries:
      - SELECT * FROM projects WHERE org_id IN user_orgs
      - SELECT * FROM repositories WHERE org_id IN user_orgs
      - SELECT * FROM team_members WHERE org_id IN user_orgs
    auto_subscribe: true
```

## Complete Example

A full configuration combining multiple techniques:

```yaml
config:
  edition: 2

streams:
  # Global reference data (no parameters, auto-subscribed)
  categories:
    query: SELECT id, name, CAST(sort_order AS TEXT) AS sort_order FROM categories
    auto_subscribe: true
  
  # User's own items with transformed fields (auth parameter, auto-subscribed)
  my_items:
    query: |
      SELECT 
        id, 
        name,
        metadata ->> 'status' AS status,
        unixepoch(created_at) AS created_at,
        base64(thumbnail) AS thumbnail
      FROM items 
      WHERE owner_id = auth.user_id()
    auto_subscribe: true
  
  # On-demand item details (subscription parameter with auth check)
  item_comments:
    query: |
      SELECT * FROM comments 
      WHERE item_id = subscription.parameter('item_id')
        AND item_id IN (SELECT id FROM items WHERE owner_id = auth.user_id())
```

See [Examples & Patterns](/sync/streams/examples) for real-world examples like multi-tenant apps and role-based access, and [Supported SQL](/sync/supported-sql) for all available operators and functions.
