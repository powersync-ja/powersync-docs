---
title: "Usage Examples"
description: "Code snippets and guidelines for common scenarios"
---

## Using transactions to group changes

Read and write transactions present a context where multiple changes can be made then finally committed to the DB or rolled back. This ensures that either all the changes get persisted, or no change is made to the DB (in the case of a rollback or exception).

The [writeTransaction(callback)](https://pub.dev/documentation/powersync/latest/sqlite_async/SqliteQueries/writeTransaction.html) method combines all writes into a single transaction, only committing to persistent storage once.

```dart
deleteList(SqliteDatabase db, String id) async {
  await db.writeTransaction((tx) async {
     // Delete the main list
     await tx.execute('DELETE FROM lists WHERE id = ?', [id]);
     // Delete any children of the list
     await tx.execute('DELETE FROM todos WHERE list_id = ?', [id]);
  });
}
```

Also see [readTransaction(callback)](https://pub.dev/documentation/powersync/latest/sqlite_async/SqliteQueries/readTransaction.html) .

## Subscribe to changes in data

Use [watch](https://pub.dev/documentation/powersync/latest/sqlite_async/SqliteQueries/watch.html) to watch for changes to the dependent tables of any SQL query.

```dart
StreamBuilder(
  // You can watch any SQL query
  stream: db.watch('SELECT * FROM customers order by id asc'),
  builder: (context, snapshot) {
    if (snapshot.hasData) {
      // TODO: implement your own UI here based on the result set
      return ...;
    } else {
      return const Center(child: CircularProgressIndicator());
    }
  },
)
```

## Insert, update, and delete data in the local database

Use [execute](https://pub.dev/documentation/powersync/latest/powersync/PowerSyncDatabase/execute.html) to run INSERT, UPDATE or DELETE queries.

```dart
FloatingActionButton(
  onPressed: () async {
    await db.execute(
      'INSERT INTO customers(id, name, email) VALUES(uuid(), ?, ?)',
      ['Fred', 'fred@example.org'],
    );
  },
  tooltip: '+',
  child: const Icon(Icons.add),
);
```

## Send changes in local data to your backend service

Override [uploadData](https://pub.dev/documentation/powersync/latest/powersync/PowerSyncBackendConnector/uploadData.html) to send local updates to your backend service.

```dart
@override
Future<void> uploadData(PowerSyncDatabase database) async {
  final batch = await database.getCrudBatch();
  if (batch == null) return;
  for (var op in batch.crud) {
    switch (op.op) {
      case UpdateType.put:
        // Send the data to your backend service
        // Replace `_myApi` with your own API client or service
        await _myApi.put(op.table, op.opData!);
        break;
      default:
        // TODO: implement the other operations (patch, delete)
        break;
    }
  }
  await batch.complete();
}
```

## Accessing PowerSync connection status information

Use [SyncStatus](https://pub.dev/documentation/powersync/latest/powersync/SyncStatus-class.html) and register an event listener with [statusStream](https://pub.dev/documentation/powersync/latest/powersync/PowerSyncDatabase/statusStream.html) to listen for status changes to your PowerSync instance.


```dart
class _StatusAppBarState extends State<StatusAppBar> {
  late SyncStatus _connectionState;
  StreamSubscription<SyncStatus>? _syncStatusSubscription;

  @override
  void initState() {
    super.initState();
    _connectionState = db.currentStatus;
    _syncStatusSubscription = db.statusStream.listen((event) {
      setState(() {
        _connectionState = db.currentStatus;
      });
    });
  }

  @override
  void dispose() {
    super.dispose();
    _syncStatusSubscription?.cancel();
  }

  @override
  Widget build(BuildContext context) {
    final statusIcon = _getStatusIcon(_connectionState);

    return AppBar(
      title: Text(widget.title),
      actions: <Widget>[
        ...
        statusIcon
      ],
    );
  }
}

Widget _getStatusIcon(SyncStatus status) {
  if (status.anyError != null) {
    // The error message is verbose, could be replaced with something
    // more user-friendly
    if (!status.connected) {
      return _makeIcon(status.anyError!.toString(), Icons.cloud_off);
    } else {
      return _makeIcon(status.anyError!.toString(), Icons.sync_problem);
    }
  } else if (status.connecting) {
    return _makeIcon('Connecting', Icons.cloud_sync_outlined);
  } else if (!status.connected) {
    return _makeIcon('Not connected', Icons.cloud_off);
  } else if (status.uploading && status.downloading) {
    // The status changes often between downloading, uploading and both,
    // so we use the same icon for all three
    return _makeIcon('Uploading and downloading', Icons.cloud_sync_outlined);
  } else if (status.uploading) {
    return _makeIcon('Uploading', Icons.cloud_sync_outlined);
  } else if (status.downloading) {
    return _makeIcon('Downloading', Icons.cloud_sync_outlined);
  } else {
    return _makeIcon('Connected', Icons.cloud_queue);
  }
}
```

## Wait for the initial sync to complete

Use the [hasSynced](https://pub.dev/documentation/powersync/latest/powersync/SyncStatus/hasSynced.html) property (available since version 1.5.1 of the SDK) and register a listener to indicate to the user whether the initial sync is in progress.

```dart
// Example of using hasSynced to show whether the first sync has completed

/// Global reference to the database
final PowerSyncDatabase db;

bool hasSynced = false;
StreamSubscription? _syncStatusSubscription;

// Use the exposed statusStream
Stream<SyncStatus> watchSyncStatus() {
  return db.statusStream;
}

@override
void initState() {
  super.initState();
  _syncStatusSubscription = watchSyncStatus.listen((status) {
    setState(() {
      hasSynced = status.hasSynced ?? false;
    });
  });
}

@override
Widget build(BuildContext context) {
  return Text(hasSynced ? 'Initial sync completed!' : 'Busy with initial sync...');
}

// Don't forget to dispose of stream subscriptions when the view is disposed
void dispose() {
  super.dispose();
  _syncStatusSubscription?.cancel();
}
```

For async use cases, see the [waitForFirstSync](https://pub.dev/documentation/powersync/latest/powersync/PowerSyncDatabase/waitForFirstSync.html) method which returns a promise that resolves once the first full sync has completed.

## Using logging to troubleshoot issues

Since version 1.1.2 of the SDK, logging is enabled by default and outputs logs from PowerSync to the console in debug mode.

## State management

Our [demo apps](/resources/demo-apps-example-projects) for Flutter are intentionally kept simple to put a focus on PowerSync APIs.
Instead of using heavy state management solutions, they use simple global fields to make the PowerSync database accessible to widgets.
For a more complex app, you might be interested in using a better approach for state management.
This section explains how PowerSync integrates with popular packages for state management.

PowerSync exposes database queries with the standard `Future` and `Stream` classes from `dart:async`. Given how widely used these are
in the Dart ecosystem, PowerSync works well with all popular approaches for state management, such as:

1. Using the `provider` package? Create your database as a `Provider` and expose watched queries to child widgets with `StreamProvider`!
   Make sure to `close()` the database in `dispose`.
2. Using `get_it` for dependency injection? PowerSync databases can be registered with `registerSingletonAsync`. Again, make sure
   to `close()` the database in the `dispose` callback.
3. Using the BLoC pattern with the `bloc` package? You can easily listen to watched queries in Cubits (although, if you find your
   Blocs and Cubits becoming trivial wrappers around database streams, consider just `watch()`ing database queries in widgets directly.
   That doesn't make your app [less testable](/client-sdk-references/flutter/unit-testing)!).
   To simplify state management, avoid the use of hydrated blocs and cubits for state that depends on database queries. With PowerSync,
   regular data is already available locally and doesn't need a second local cache.

### Riverpod

We have a [complete example](https://github.com/powersync-ja/powersync.dart/tree/main/demos/supabase-todolist-drift) demonstrating how
PowerSync can be used in an app using [Riverpod](https://riverpod.dev) for state management.
This section also provides a few relevant snippets and explanations.

In this example, we use a simple utility to make `NotifierProvider`s easier to create:

```dart
import 'package:riverpod/riverpod.dart';

final class _StatefulNotifier<T> extends Notifier<T> {
  T? _currentValue;
  final T Function(Ref, void Function(T)) _initial;

  _StatefulNotifier(this._initial);

  @override
  T build() => _currentValue ??= _initial(ref, (updated) {
        _currentValue = state = updated;
      });
}

/// A [NotifierProvider] that exposes the [Notifier.state] setter to the
/// [initialValue] function, allowing notifier providers to be written without
/// a custom notifier for each provider.
NotifierProvider<Notifier<T>, T> statefulProvider<T>(
  T Function(Ref ref, void Function(T) change) initialValue,
) {
  return NotifierProvider(() => _StatefulNotifier<T>(initialValue));
}
```

#### Opening the database

To open a `PowerSync` database with Riverpod, wrap the initialization logic in an async provider:

```dart
@Riverpod(keepAlive: true)
Future<PowerSyncDatabase> initializePowerSync(Ref ref) async {
  final db = PowerSyncDatabase(
      schema: schema, path: await _getDatabasePath(), logger: attachedLogger);
  await db.initialize();
  ref.onDispose(db.close);
  return db;
}
```

To automatically connect and disconnect your backend connector depending on the current auth state,
you could use side effects in that provider. With Supabase, that may look like this:

```dart
final session = statefulProvider<Session?>((ref, change) {
  final instance = Supabase.instance.client.auth;

  final sub = instance.onAuthStateChange.listen((data) {
    change(instance.currentSession);
  });
  ref.onDispose(sub.cancel);

  return instance.currentSession;
});

@Riverpod(keepAlive: true)
Future<PowerSyncDatabase> initializePowerSync(Ref ref) async {
  final db = PowerSyncDatabase(
      schema: schema, path: await _getDatabasePath(), logger: attachedLogger);
  await db.initialize();

  SupabaseConnector? currentConnector;

  if (ref.read(session) != null) {
    currentConnector = SupabaseConnector();
    db.connect(connector: currentConnector);
  }

  final instance = Supabase.instance.client.auth;
  final sub = instance.onAuthStateChange.listen((data) async {
    final event = data.event;
    if (event == AuthChangeEvent.signedIn) {
      // Connect to PowerSync when the user is signed in
      currentConnector = SupabaseConnector();
      db.connect(connector: currentConnector!);
    } else if (event == AuthChangeEvent.signedOut) {
      // Implicit sign out - disconnect, but don't delete data
      currentConnector = null;
      await db.disconnect();
    } else if (event == AuthChangeEvent.tokenRefreshed) {
      // Supabase token refreshed - trigger token refresh for PowerSync.
      currentConnector?.prefetchCredentials();
    }
  });
  ref.onDispose(sub.cancel);

  return db;
}
```

#### Running queries

To expose auto-updating query results, use a `StreamProvider` reading the database:

```dart
final _lists = StreamProvider((ref) async* {
  final database = await ref.read(initializePowerSyncProvider.future);
  yield* database.watch('SELECT * FROM lists');
});
```

#### Waiting for sync

If you were awaiting `waitForFirstSync` before, you can keep doing that:

```dart
final db = await ref.read(initializePowerSyncProvider.future);
await db.waitForFirstSync();
```

Alternatively, you can expose the sync status as a provider and use that to determine
whether the synchronization has completed:

```dart
final syncStatus = statefulProvider<SyncStatus>((ref, change) {
  final status = Stream.fromFuture(ref.read(initializePowerSyncProvider.future))
      .asyncExpand((db) => db.statusStream);
  final sub = status.listen(change);
  ref.onDispose(sub.cancel);

  return const SyncStatus();
});

@riverpod
bool didCompleteSync(Ref ref, [BucketPriority? priority]) {
  final status = ref.watch(syncStatus);
  if (priority != null) {
    return status.statusForPriority(priority).hasSynced ?? false;
  } else {
    return status.hasSynced ?? false;
  }
}

final class MyWidget extends ConsumerWidget {
  const MyWidget({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final didSync = ref.watch(didCompleteSyncProvider());

    if (!didSync) {
      return const Text('Busy with sync...');
    }

    // ... content after first sync
  }
}
```

#### Attachment queue

If you're using the attachment queue helper to synchronize media assets, you can also wrap that in a provider:

```dart
@Riverpod(keepAlive: true)
Future<PhotoAttachmentQueue> attachmentQueue(Ref ref) async {
  final db = await ref.read(initializePowerSyncProvider.future);
  final queue = PhotoAttachmentQueue(db, remoteStorage);
  await queue.init();
  return queue;
}
```

Reading and awaiting this provider can then be used to show attachments:

```dart
final class PhotoWidget extends ConsumerWidget {
  final TodoItem todo;

  const PhotoWidget({super.key, required this.todo});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final photoState = ref.watch(_getPhotoStateProvider(todo.photoId));
    if (!photoState.hasValue) {
      return Container();
    }

    final data = photoState.value;
    if (data == null) {
      return Container();
    }

    String? filePath = data.photoPath;
    bool fileIsDownloading = !data.fileExists;
    bool fileArchived =
        data.attachment?.state == AttachmentState.archived.index;

    if (fileArchived) {
      return Column(
        crossAxisAlignment: CrossAxisAlignment.center,
        mainAxisAlignment: MainAxisAlignment.center,
        children: [
          const Text("Unavailable"),
          const SizedBox(height: 8),
        ],
      );
    }

    if (fileIsDownloading) {
      return const Text("Downloading...");
    }

    File imageFile = File(filePath!);
    int lastModified = imageFile.existsSync()
        ? imageFile.lastModifiedSync().millisecondsSinceEpoch
        : 0;
    Key key = ObjectKey('$filePath:$lastModified');

    return Image.file(
      key: key,
      imageFile,
      width: 50,
      height: 50,
    );
  }
}

class _ResolvedPhotoState {
  String? photoPath;
  bool fileExists;
  Attachment? attachment;

  _ResolvedPhotoState(
      {required this.photoPath, required this.fileExists, this.attachment});
}

@riverpod
Future<_ResolvedPhotoState> _getPhotoState(Ref ref, String? photoId) async {
  if (photoId == null) {
    return _ResolvedPhotoState(photoPath: null, fileExists: false);
  }
  final queue = await ref.read(attachmentQueueProvider.future);
  final photoPath = await queue.getLocalUri('$photoId.jpg');

  bool fileExists = await File(photoPath).exists();

  final row = await queue.db
      .getOptional('SELECT * FROM attachments_queue WHERE id = ?', [photoId]);

  if (row != null) {
    Attachment attachment = Attachment.fromRow(row);
    return _ResolvedPhotoState(
        photoPath: photoPath, fileExists: fileExists, attachment: attachment);
  }

  return _ResolvedPhotoState(
      photoPath: photoPath, fileExists: fileExists, attachment: null);
}
```