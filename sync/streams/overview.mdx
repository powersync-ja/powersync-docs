---
title: "Sync Streams"
description: Sync Streams enable partial syncing, letting you define exactly which data from your backend can sync to each client using simple SQL-like queries.
sidebarTitle: "Quickstart"
---

import StreamDefinitionReference from '/snippets/stream-definition-reference.mdx';

Instead of syncing entire tables, you tell PowerSync exactly which data each user/client can sync. You write simple SQL-like queries to define streams of data, and your client app subscribes to the streams it needs. PowerSync handles the rest, keeping data in sync in real-time and making it available offline.

For example, you might create a stream that syncs only the current user's to-do items, another for shared projects they have access to, and another for reference data that everyone needs. Your app subscribes to these streams on demand, and only that data syncs to the client-side SQLite database.

<Note>
**Beta Release**

Sync Streams are now in beta and production-ready. We recommend Sync Streams for all new projects, and encourage existing projects to [migrate from Sync Rules](/sync/streams/migration).

We welcome your feedback — please share with us in [Discord](https://discord.gg/powersync).
</Note>

## Defining Streams

Streams are defined in a YAML configuration file. Each stream has a **name** and a **query** that specifies which rows to sync using SQL-like syntax. The query can reference [parameters](/sync/overview#how-it-works) like the authenticated user's ID to personalize what each user receives.

<Tabs>
<Tab title="PowerSync Cloud">
In the [PowerSync Dashboard](https://dashboard.powersync.com/):

1. Select your project and instance
2. Go to **Sync Streams**
3. Edit the YAML directly in the dashboard
4. Click **Deploy** to validate and deploy

```yaml
config:
  edition: 2

streams:
  todos:
    query: SELECT * FROM todos WHERE owner_id = auth.user_id()
```
</Tab>

<Tab title="Self-Hosted">
Add a `sync_config` section to your `config.yaml`:

```yaml config.yaml
sync_config:
  content: |
    config:
      edition: 2

    streams:
      todos:
        query: SELECT * FROM todos WHERE owner_id = auth.user_id()
```
</Tab>
</Tabs>

Available stream options:

<StreamDefinitionReference />

## Basic Examples

There are two independent concepts to understand:

- _What_ data the stream returns. For example:
  - *Global data*: No parameters. Same data for all users (e.g. reference tables like categories).
  - *Filtered data*: Filters the data by a parameter value. This can make use of _auth parameters_ from the JWT token (such as the user ID or other JWT claims), _subscription parameters_ (specified by the client when it subscribes to a stream at any time), or _connection parameters_ (specified at connection). Different users will get different sets of data based on the parameters. See [Using Parameters](/sync/streams/parameters) for the full reference.
- _When_ the client syncs the data
  - *Auto-subscribe*: Client automatically subscribes on connect (`auto_subscribe: true`)
  - *On-demand*: Client explicitly subscribes when needed (default behavior)

### Global Data

Data without parameters is "global" data, meaning the same data goes to all users/clients. This is useful for reference tables:

```yaml
config:
  edition: 2

streams:
  # Same categories for everyone
  categories:
    query: SELECT * FROM categories

  # Same active products for everyone
  products:
    query: SELECT * FROM products WHERE active = true
```

<Note>
Global data streams still require clients to subscribe explicitly unless you set `auto_subscribe: true`
</Note>

### Filtering Data by User

Use `auth.user_id()` or other [JWT claims](/sync/streams/parameters#auth-parameters) to return different data per user:

```yaml
config:
  edition: 2

streams:
  # Each user gets their own lists
  my_lists:
    query: SELECT * FROM lists WHERE owner_id = auth.user_id()

  # Each user gets their own orders
  my_orders:
    query: SELECT * FROM orders WHERE user_id = auth.user_id()
```

### Filtering Data Based on Subscription Parameters

Use `subscription.parameter()` for data that clients subscribe to explicitly:

```yaml
config:
  edition: 2

streams:
  # Sync todos for a specific list when the client subscribes with a list_id
  list_todos:
    query: |
      SELECT * FROM todos 
      WHERE list_id = subscription.parameter('list_id')
        AND list_id IN (SELECT id FROM lists WHERE owner_id = auth.user_id())
```

```js
// Client subscribes with the list they want to view
const sub = await db.syncStream('list_todos', { list_id: 'abc123' }).subscribe();
```

### Using Auto-Subscribe

Set `auto_subscribe: true` to sync data automatically when clients connect. This is useful for:
- Reference data that all users need, or that are needed in many screens in the app.
- User data that should always be available offline
- Maintaining [Sync Rules](/sync/rules/overview) default behavior ("sync everything upfront") when migrating to Sync Streams

```yaml
config:
  edition: 2

streams:
  # Global data, synced automatically
  categories:
    query: SELECT * FROM categories
    auto_subscribe: true

  # User-scoped data, synced automatically
  my_orders:
    query: SELECT * FROM orders WHERE user_id = auth.user_id()
    auto_subscribe: true

  # Parameterized data, subscribed on-demand (no auto_subscribe)
  order_items:
    query: |
      SELECT * FROM order_items 
      WHERE order_id = subscription.parameter('order_id')
        AND order_id IN (SELECT id FROM orders WHERE user_id = auth.user_id())
```


## Client-Side Usage

Subscribe to streams from your client app:

<Tabs>
<Tab title="JavaScript/TypeScript">
```js
const sub = await db.syncStream('list_todos', { list_id: 'abc123' })
  .subscribe({ ttl: 3600 });

// Wait for this subscription to have synced
await sub.waitForFirstSync();

// When the component needing the subscription is no longer active...
sub.unsubscribe();
```

**React hooks:**

```jsx
const stream = useSyncStream({ name: 'list_todos', parameters: { list_id: 'abc123' } });
// Check download progress or subscription information
stream?.progress;
stream?.subscription.hasSynced;
```

The `useQuery` hook can wait for Sync Streams before running queries:

```jsx
const { data } = useQuery(
  'SELECT * FROM todos WHERE list_id = ?',
  [listId],
  { streams: [{ name: 'list_todos', parameters: { list_id: listId }, waitForStream: true }] }
);
```
</Tab>

<Tab title="Dart">
```dart
final sub = await db
  .syncStream('list_todos', {'list_id': 'abc123'})
  .subscribe(ttl: const Duration(hours: 1));

// Wait for this subscription to have synced
await sub.waitForFirstSync();

// When the component needing the subscription is no longer active...
sub.unsubscribe();
```
</Tab>

<Tab title="Kotlin">
```kotlin
val sub = database.syncStream("list_todos", mapOf("list_id" to JsonParam.String("abc123")))
  .subscribe(ttl = 1.0.hours)

// Wait for this subscription to have synced
sub.waitForFirstSync()

// When the component needing the subscription is no longer active...
sub.unsubscribe()
```

**Compose:**

```kotlin
@Composable
fun TodoListPage(db: PowerSyncDatabase, listId: String) {
  val stream = db.composeSyncStream(
    name = "list_todos", 
    parameters = mapOf("list_id" to JsonParam.String(listId))
  )
  // Define component based on stream state
}
```
</Tab>

<Tab title="Swift">
```swift
let sub = try await db.syncStream(name: "list_todos", params: ["list_id": JsonValue.string("abc123")])
  .subscribe(ttl: 60 * 60, priority: nil) // 1 hour

// Wait for this subscription to have synced
try await sub.waitForFirstSync()

// When the component needing the subscription is no longer active...
try await sub.unsubscribe()
```
</Tab>

<Tab title=".NET">
```csharp
var sub = await db.SyncStream("list_todos", new() { ["list_id"] = "abc123" })
  .Subscribe(new SyncStreamSubscribeOptions { Ttl = TimeSpan.FromHours(1) });

// Wait for this subscription to have synced
await sub.WaitForFirstSync();

// When the component needing the subscription is no longer active...
sub.Unsubscribe();
```
</Tab>
</Tabs>

### TTL (Time-To-Live)

Each subscription has a `ttl` that keeps data cached after unsubscribing. This enables warm cache behavior — when users return to a screen and you re-subscribe to relevant streams, data is already available on the client. Default TTL is 24 hours. See [Client-Side Usage](/sync/streams/client-usage) for details.

```js
// Set TTL in seconds when subscribing
const sub = await db.syncStream('todos', { list_id: 'abc' })
  .subscribe({ ttl: 3600 }); // Cache for 1 hour after unsubscribe
```
## Developer Notes

- **SQL Syntax**: Stream queries use a SQL-like syntax with `SELECT` statements. You can use subqueries, `INNER JOIN`, and [CTEs](/sync/streams/ctes) for filtering. `GROUP BY`, `ORDER BY`, and `LIMIT` are not supported. See [Writing Queries](/sync/streams/queries) for details on joins, multiple queries per stream, and other features.

- **Type Conversion**: Data types from your source database (Postgres, MongoDB, MySQL, SQL Server) are converted when synced to the client's SQLite database. SQLite has a limited type system, so most types become `text` and you may need to parse or cast values in your app code. See [Type Mapping](/sync/types) for details on how each type is handled.

- **Primary Key**: PowerSync requires every synced table to have a primary key column named `id` of type `text`. If your backend uses a different column name or type, you'll need to map it. For MongoDB, the `_id` field automatically maps to `id`. See [Client ID](/sync/advanced/client-id) for setup instructions.

- **Case Sensitivity**: To avoid issues across different databases and platforms, use **lowercase identifiers** for all table and column names in your Sync Streams. If your backend uses mixed case, see [Case Sensitivity](/sync/advanced/case-sensitivity) for how to handle it.

- **Bucket Limits**: PowerSync uses internal partitions called [buckets](/architecture/powersync-service#bucket-system) to efficiently sync data. There's a default [limit of 1,000 buckets](/resources/performance-and-limits) per user/client. Each unique combination of a stream and its parameters creates one bucket, so keep this in mind when designing streams that use subscription parameters. You can use [multiple queries per stream](/sync/streams/queries#multiple-queries-per-stream) to reduce bucket count. 

- **Troubleshooting**: If data isn't syncing as expected, the [Sync Diagnostics Client](/tools/diagnostics-client) helps you inspect what's happening for a specific user — you can see which buckets the user has and what data is being synced.

## Examples & Demos

See [Examples & Demos](/sync/streams/examples) for working demo apps and complete application patterns.

## Migrating from Legacy Sync Rules

If you have an existing project using legacy Sync Rules, see the [Migration Guide](/sync/streams/migration) for step-by-step instructions, syntax changes, and examples.
