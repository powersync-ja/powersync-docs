---
title: "ServerPod + PowerSync"
description: "Easily make your ServerPod projects offline-ready with PowerSync"
sidebarTitle: "Serverpod"
---

import PostgresPowerSyncUser from '/snippets/postgres-powersync-user.mdx';
import PostgresPowerSyncPublication from '/snippets/postgres-powersync-publication.mdx';

Used in conjunction with [ServerPod](https://serverpod.dev/), PowerSync enables developers to build local-first apps that are robust in poor network conditions
and that have highly responsive frontends while relying on Serverpod for shared models in a full-stack Dart project.
This guide walks you through configuring PowerSync within your Serverpod project.

## Overview

PowerSync works by:

1. Automatically streaming changes from your Postgres backend database into a SQLite database on the client.
2. Collecting local writes that users have performed on the SQLite database, and allowing you to upload those writes to Postgres.

<Check>See [Architecture Overview](/architecture/architecture-overview) for a full overview.</Check>

To integrate PowerSync into a Serverpod project, a few aspects need to be considered:

<Steps>
  <Step icon="database" title="Database setup">
    Your Serverpod models need to be persisted into a Postgres database.
  </Step>
  <Step icon="gear" title="PowerSync configuration">
    PowerSync needs access to your Postgres database to stream changes to users.
  </Step>
  <Step icon="lock" title="Authentication">
    To ensure each user only has access to the data they're supposed to see, Serverpod
    authenticates users against PowerSync.
  </Step>
  <Step icon="arrows-rotate" title="Data sync">
    After configuring your clients, your Serverpod projects are offline-ready!
  </Step>
</Steps>

This guide shows all steps in detail. Here, we assume you're working with a fresh Serverpod project.
You can follow along by creating a prooject:

```
serverpod create notes
```

Of course, all steps and migrations also apply to established projects.

## Database setup

Begin by [setting up the source database](/installation/database-setup). PowerSync requires logical replication
to be enabled. With the `docker-compose.yaml` file generated by Serverpod, add a `command` to the `postgres`
service to enable this option.
This is also a good opportunity to add a health check, which helps PowerSync connect at the right time later:

```yaml
services:
  # Development services
  postgres:
    image: pgvector/pgvector:pg16
    ports:
      - "8090:5432"
    command: ["postgres", "-c", "wal_level=logical"] # Added for PowerSync
    environment:
      POSTGRES_USER: postgres
      POSTGRES_DB: notes
      # ...
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U postgres -d postgres"]
      interval: 5s
      timeout: 5s
      retries: 5
    volumes:
      - notes_data:/var/lib/postgresql/data

```

Next, configure existing models to be persisted in the database. In the template created by
Serverpod, edit `notes_server/lib/src/greeting.spy.yaml`:

```yaml
### A greeting message which can be sent to or from the server.
class: Greeting

table: greeting # Added table key

fields:
  ### Important! Each model used with PowerSync needs to have a UUID id column.
  id: UuidValue,defaultModel=random,defaultPersist=random
  ### The user id owning this greeting, used for access control in PowerSync
  owner: String

  ### The greeting message.
  message: String
  ### The author of the greeting message.
  author: String
  ### The time when the message was created.
  timestamp: DateTime
```

After making the changes, run `serverpod generate` and ignore the issues in `greeting_endpoint.dart` for now.
Instead, run `serverpod create-migration` and note the generated path:

```
$ serverpod create-migration

✓ Creating migration (87ms)
 • Migration created: migrations/<migration id>
✅ Done.
```

We will use the migration adding the `greeting` table to also configure a replication that PowerSync will hook into.
For that, edit `notes_server/migrations/<migration id>/migration.sql`
At the end of that file, after `COMMIT;`, add this:

<PostgresPowerSyncUser />

This is also a good place to setup a Postgres publication that a PowerSync service will subscribe to:

<PostgresPowerSyncPublication />

After adding these statements to `migration.sql`, also add them to `definition.sql`. The reason is that Serverpod
runs that file when instantiating the database from scratch, `migration.sql` would be ignored in that case.

## PowerSync configuration

PowerSync requires a service to process Postgres writes into a form that can be synced to clients.
Additionally, your Serverpod backend will be responsible for generating JWTs to authenticate clients as
they connect to this service.

To set that up, begin by generating an RSA key to sign these JWTs. In the server project, run
`dart pub add jose` to add a package supporting JWTs in Dart.
Then, create a `tool/generate_keys.dart` that prints a new key pair when run:

<Expandable title="tool/generate_keys.dart">
```dart
import 'dart:convert';
import 'dart:math';

import 'package:jose/jose.dart';

void main() {
  var generatedKey = JsonWebKey.generate('RS256').toJson();
  final kid = 'powersync-${generateRandomString(8)}';
  generatedKey = {...generatedKey, 'kid': kid};

  print('''
      JS_JWK_N: ${generatedKey['n']}
      PS_JWK_E: ${generatedKey['e']}
      PS_JWK_KID: $kid
''');

  final encodedKeys = base64Encode(utf8.encode(json.encode(generatedKey)));
  print('JWT signing keys for backend: $encodedKeys');
}

String generateRandomString(int length) {
  final random = Random.secure();
  final buffer = StringBuffer();

  for (var i = 0; i < length; i++) {
    const alphabet = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ';

    buffer.writeCharCode(alphabet.codeUnitAt(random.nextInt(alphabet.length)));
  }

  return buffer.toString();
}
```
</Expandable>

Run `dart run tool/generate_jwt.dart` and save its output, it's needed for the next step as well.

For development, you can add the PowerSync service to the compose file.
It needs access to the source database, a Postgres database to store intermediate data,
and the public half of the generated signing key.

```yaml
services:
  powersync:
    restart: unless-stopped
    image: journeyapps/powersync-service:latest
    depends_on:
      postgres:
        condition: service_healthy
    command: ["start", "-r", "unified"]
    volumes:
      - ./powersync.yaml:/config/config.yaml
    environment:
      POWERSYNC_CONFIG_PATH: /config/config.yaml
      # Use the credentials created in the previous step, the /notes is the datase name for Postgres
      PS_SOURCE_URI: "postgresql://powersync_role:myhighlyrandompassword@postgres:5432/notes"
      PS_STORAGE_URI: "postgresql://powersync_role:myhighlyrandompassword@postgres:5432/powersync_storage"
      JS_JWK_N: # output from generate_keys.dart
      PS_JWK_E: AQAB # output from generate_keys.dart
      PS_JWK_KID: # output from generate_keys.dart
    ports:
      - 8095:8080
```

To configure PowerSync, create a file called `powersync.yaml` next to the compose file.
This file configures how PowerSync connects to the source database, how to authenticate users,
and which data to sync:

```yaml
replication:
  connections:
    - type: postgresql
      uri: !env PS_SOURCE_URI

      # SSL settings
      sslmode: disable # 'verify-full' (default) or 'verify-ca' or 'disable'

# Connection settings for sync bucket storage
storage:
  type: postgresql
  uri: !env PS_STORAGE_URI
  sslmode: disable # 'verify-full' (default) or 'verify-ca' or 'disable'

# The port which the PowerSync API server will listen on
port: 8080

sync_rules:
  content: |
    streams:
      todos:
        # For each user, sync all greeting they own.
        query: SELECT * FROM greeting WHERE owner = request.user_id()
        auto_subscribe: true # Sync by default
    config:
      edition: 2

client_auth:
  audience: [powersync]
  jwks:
    keys:
      - kty: RSA
        n: !env PS_JWK_N
        e: !env PS_JWK_E
        alg: RS256
        kid: !env PS_JWK_KID
```

<Tip>More information on available options is available under [PowerSync Service Setup](/self-hosting/installation/powersync-service-setup)</Tip>

## Authentication

PowerSync processes the entire source database [into buckets](/usage/sync-rules/organize-data-into-buckets), an efficient representation
for sync. With the configuration shown here, there is one such bucket per user storing all `greeting`s owned by that user.
For security, it is crucial each user only has access to their own bucket. This is why PowerSync gives you full access control:

1. When a client connects to PowerSync, it fetches an authentication token from your Serverpod instance.
2. Your Dart backend logic returns a JWT describing what data the user should have acecss to.
3. In the `sync_rules` section, you reference properties of the created JWTs to control data visible to the connecting clients.

In this guide, we will use a single virtual user for everything. For real projects, follow
[Serverpod documentation on authentication](https://docs.serverpod.dev/tutorials/guides/authentication).

PowerSync needs two endpoints, one to request a JWT and one to upload local writes from clients to the backend database.
In `notes_server/lib/src/powersync_endpoint.dart`, create those endpoints:

```dart
import 'dart:convert';
import 'dart:isolate';

import 'generated/protocol.dart';
import 'package:serverpod/serverpod.dart';
import 'package:jose/jose.dart';

class PowerSyncEndpoint extends Endpoint {
  Future<String> createJwt(Session session) async {
    // TODO: Throw if the session is unauthenticated.

    // TODO: Extract user-id from session outsie
    final userId = 'global_user';
    final token = await Isolate.run(() => _createPowerSyncToken(userId));

    // Also create default greeting if none exist for this user.
    if (await session.db.count(where: Greeting.t.author.equals(userId)) == 0) {
      await Greeting.db.insertRow(
        session,
        Greeting(
          owner: userId,
          message: 'Hello from Serverpod and PowerSync',
          author: 'admin',
          timestamp: DateTime.now(),
        ),
      );
    }

    return token;
  }

  /// Upload a batch of local writes to the backend database.
  Future<void> applyChanges(Session session, List<Greeting> greetings) async {
    // TODO: Throw if the session is unauthenticated.
    await session.db.transaction((tx) async {
      for (final greeting in greetings) {
        // TODO: Throw if the user is not allowed to write to this greeting.
        final existing =
            await Greeting.db.findById(session, greeting.id, transaction: tx);
        if (existing == null) {
          await Greeting.db.insertRow(session, greeting, transaction: tx);
        } else {
          await Greeting.db.updateRow(session, greeting, transaction: tx);
        }
      }
    });
  }
}

Future<String> _createPowerSyncToken(String userId) async {
  final decoded = _jsonUtf8.decode(base64.decode(_signingKey));
  final signingKey = JsonWebKey.fromJson(decoded as Map<String, Object?>);

  final now = DateTime.now();

  final builder = JsonWebSignatureBuilder()
    ..jsonContent = {
      'sub': userId,
      'iat': now.millisecondsSinceEpoch ~/ 1000,
      'exp': now.add(Duration(minutes: 10)).millisecondsSinceEpoch ~/ 1000,
      'aud': ['powersync'],
      'kid': _keyId,
    }
    ..addRecipient(signingKey, algorithm: 'RS256');

  final jwt = builder.build();
  return jwt.toCompactSerialization();
}

final _jsonUtf8 = JsonCodec().fuse(Utf8Codec());

const _signingKey = 'TODO'; // The "JWT signing keys for backend" bit from tool/generate_keys.dart
const _keyId = 'TODO'; // PS_JWK_KID from tool/generate_keys.dart
```

You can delete the existing `greeting_endpoint.dart` file, it's not necessary since PowerSync is used to fetch data from your server.
Also remove invocations related to future calls in `lib/server.dart`.
Don't forget to run `serverpod generate` afterwards.

## Data sync

With all services, configured, it's time to spin up development services:

```
docker compose down
docker compose up --detach --scale powersync=0

# This creates the PowerSync role
dart run bin/main.dart --role maintenance --apply-migrations

# Create the PowerSync bucket storage database, use password from docker-compose.yaml
psql -h 127.0.0.1 -p 8090 -U postgres

Password from user postgres: <from compose>
postgres=# CREATE DATABASE powersync_storage WITH OWNER = powersync_role;
postgres=# \q

docker compose down
```

## Next steps

TODO: Guide to cloud version.
