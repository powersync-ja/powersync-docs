---
title: "Swift (Alpha)"
---

<Note>
    The PowerSync Swift SDK is currently in an alpha release. It is not suitable for production use at this stage unless you've tested your use cases extensively. Breaking changes are still likely to occur.
</Note>

## Kotlin Multiplatform -> Native Swift SDK

This SDK is an extension of the [Kotlin Multiplatform SDK](https://github.com/powersync-ja/powersync-kotlin), and utilizes the API tool [SKIE](https://skie.touchlab.co/) to generate and publish a [PowerSync SDK](https://github.com/powersync-ja/powersync-kotlin/tree/main/PowerSync) that can be used in a standalone Swift app. Further details about this configuration can be found in our blog [here](https://www.powersync.com/blog/using-kotlin-multiplatform-with-kmmbridge-and-skie-to-publish-a-native-swift-sdk).

<Info>
**Demo App**

We recommend the [Supabase Todo List Demo](https://github.com/powersync-ja/powersync-kotlin-swift-demo) app as a starting point for using the Swift SDK. See the README for details to run it.
</Info>

### SDK Features

* Provides real-time streaming of database changes.
* Offers direct access to the SQLite database, enabling the use of SQL on both client and server sides.
* Operations are asynchronous by default, ensuring the user interface remains unblocked.
* Supports concurrent database operations, allowing one write and multiple reads simultaneously.
* Enables subscription to queries for receiving live updates.
* Eliminates the need for client-side database migrations as these are managed automatically.

## Installation

1. Using `Package.swift:`

```swift
let package = Package(
    ...
    dependencies: [
        ...
        .package(
            url: "https://github.com/powersync-ja/powersync-kotlin",
            exact: "1.0.0-BETA5.0"
        ),
        .package(
            url: "https://github.com/powersync-ja/powersync-sqlite-core-swift",
        ),
    ],
    targets: [
        .target(
            name: "YourTargetName",
            dependencies: [
                .product(
                    name: "PowerSync",
                    package: "powersync-kotlin"
                ),
                .product(
                    name: "PowerSyncSqliteCore",
                    package: "powersync-sqlite-core-swift"
                ),
            ]
        )
    ]
)
```

2.  Using Xcode:

    1. Follow [this](https://developer.apple.com/documentation/xcode/adding-package-dependencies-to-your-app#Add-a-package-dependency) guide to add a package to your project.
    2.  When searching for the package use [https://github.com/powersync-ja/powersync-kotlin.git](https://github.com/powersync-ja/powersync-kotlin.git) as the URL and include the exact version `1.0.0-BETA5.0` as shown below:

    <Frame>
        
        <img src="/images/swift.avif"></img>
    </Frame>

    3. Do the same for `power-sqlite-core-swift` using [https://github.com/powersync-ja/powersync-sqlite-core-swift.git](https://github.com/powersync-ja/powersync-kotlin.git) and choose a range between `0.3.1` and `0.4.0` as shown below:

    <Frame>
        <img src="/images/image (1).png"></img>
    </Frame>

<Note>
    Use the exact version for `powersync-kotlin` as we are actively making changes to the Swift SDK which could result in breaking changes. The version history can be found [here](https://central.sonatype.com/artifact/com.powersync/core/versions).
</Note>

## Getting Started

Before implementing the PowerSync SDK in your project, make sure you have completed these steps:

* Signed up for a PowerSync Cloud account ([here](https://accounts.journeyapps.com/portal/get-started?powersync=true)) or [self-host PowerSync](/self-hosting/getting-started).
* [Configured your backend database](/usage/installation/database-setup) and connected it to your PowerSync instance.
* [Installed](/client-sdk-references/swift#installation) the PowerSync SDK.

### 1\. Define the Schema

The first step is defining the schema for the local SQLite database, which is provided to the `PowerSyncDatabase` constructor via the `schema` parameter. This schema represents a "view" of the downloaded data. No migrations are required — the schema is applied directly when the PowerSync database is constructed.

The types available are `text`, `integer` and `real`. These should map directly to the values produced by the [Sync Rules](/usage/sync-rules). If a value doesn't match, it is cast automatically.

**Example**:
```js
import Foundation
import PowerSync

let LISTS_TABLE = "lists"
let TODOS_TABLE = "todos"

let lists = Table(
    name: LISTS_TABLE,
    columns: [
        // ID column is automatically included
        Column(name: "name", type: ColumnType.text),
        Column(name: "created_at", type: ColumnType.text),
        Column(name: "owner_id", type: ColumnType.text)
    ],
    indexes: [],
    localOnly: false,
    insertOnly: false,
    viewNameOverride: LISTS_TABLE
)

let todos = Table(
    name: TODOS_TABLE,
    // ID column is automatically included
    columns: [
        Column(name: "list_id", type: ColumnType.text),
        Column(name: "photo_id", type: ColumnType.text),
        Column(name: "description", type: ColumnType.text),
        // 0 or 1 to represent false or true
        Column(name: "completed", type: ColumnType.integer),
        Column(name: "created_at", type: ColumnType.text),
        Column(name: "completed_at", type: ColumnType.text),
        Column(name: "created_by", type: ColumnType.text),
        Column(name: "completed_by", type: ColumnType.text)
    ],
    indexes: [
        Index(
            name: "list_id",
            columns: [
                IndexedColumn(column: "list_id", ascending: true, columnDefinition: nil, type: nil)
            ]
        )
    ],
    localOnly: false,
    insertOnly: false,
    viewNameOverride: TODOS_TABLE
)

let AppSchema = Schema(tables: [lists, todos])
```

<Info>
    **Note**: No need to declare a primary key `id` column, as PowerSync will automatically create this.
</Info>

### 2\. Instantiate the PowerSync Database

Next, you need to instantiate the PowerSync database — this is the core managed database.

Its primary function is to record all changes in the local database, whether online or offline. In addition, it automatically uploads changes to your app backend when connected.

**Example**:

```js
// Comes from the PowerSync package
let factory = DatabaseDriverFactory()
// Comes from the AppSchema defined above
let schema = AppSchema
var db = PowerSyncDatabase(
    factory: factory,
    schema: schema,
    dbFilename: "powersync-swift.sqlite",
    params: [:]
)
```

### 3\. Integrate with your Backend

Create a connector to integrate with your backend. The PowerSync backend connector provides the connection between your application backend and the PowerSync managed database.

It is used to:

1. Retrieve an auth token to connect to the PowerSync instance.
2. Apply local changes on your backend application server (and from there, to Postgres)

Accordingly, the connector must implement two methods:

1. `PowerSyncBackendConnector.fetchCredentials` \- This is called every couple of minutes and is used to obtain credentials for your app's backend API. -> See [Authentication Setup](/usage/installation/authentication-setup) for instructions on how the credentials should be generated.
2. `PowerSyncBackendConnector.uploadData` \- Use this to upload client-side changes to your app backend.
\-> See [Writing Client Changes](/usage/installation/app-backend-setup/writing-client-changes) for considerations on the app backend implementation.

**Example**:

```js
import PowerSync

@Observable
@MainActor
class MyConnector: PowerSyncBackendConnector {
    override func fetchCredentials() async throws -> PowerSyncCredentials? {
    // implement fetchCredentials to obtain the necessary credentials to connect to your backend
    // See an example implementation in https://github.com/powersync-ja/powersync-kotlin-swift-demo/blob/main/PowerSyncExample/PowerSync/SupabaseConnector.swift

        return {
            endpoint: '[Your PowerSync instance URL or self-hosted endpoint]',
            // Use a development token (see Authentication Setup https://docs.powersync.com/usage/installation/authentication-setup/development-tokens)
            // to get up and running quickly) to get up and running quickly
            token: 'An authentication token'
        }
    }

    override func uploadData(database: any PowerSyncDatabase) async throws {
        // Implement uploadData to send local changes to your backend service
        // You can omit this method if you only want to sync data from the server to the client
        // See an example implementation under Usage Examples (sub-page)
        // See https://docs.powersync.com/usage/installation/app-backend-setup/writing-client-changes for considerations.
    }
}

```

<Info>
    If you are using **Supabase**, you can use [SupabaseConnector.swift](https://github.com/powersync-ja/powersync-kotlin-swift-demo/blob/main/PowerSyncExample/PowerSync/SupabaseConnector.swift) as a starting point.
</Info>

## Using PowerSync: CRUD functions

Once the PowerSync instance is configured you can start using the SQLite DB functions.

The most commonly used CRUD functions to interact with your SQLite data are:

* [PowerSyncDatabase.get](/client-sdk-references/swift#fetching-a-single-item) \- get (SELECT) a single row from a table.
* [PowerSyncDatabase.getOptional](/client-sdk-references/swift#fetching-a-single-item) \- get (SELECT) a single row from a table and return `null` if not found.
* [PowerSyncDatabase.getAll](/client-sdk-references/swift#querying-items-powersync.getall) \- get (SELECT) a set of rows from a table.
* [PowerSyncDatabase.watch](/client-sdk-references/swift#watching-queries-powersync.watch) \- execute a read query every time source tables are modified.
* [PowerSyncDatabase.execute](/client-sdk-references/swift#mutations-powersync.execute) \- execute a write (INSERT/UPDATE/DELETE) query.

### Fetching a Single Item ( PowerSync.get / PowerSync.getOptional)

The `get` method executes a read-only (SELECT) query and returns a single result. It throws an exception if no result is found. Use `getOptional` to return a single optional result (returns `null` if no result is found).

```js
// Find a list item by ID
func getList(_ id: String) async throws {
    try await self.db.getAll(
        sql: "SELECT * FROM \(LISTS_TABLE) WHERE id = ?",
        parameters: [id],
        mapper: { cursor in
            ListContent(
                id: cursor.getString(index: 0)!,
                name: cursor.getString(index: 1)!,
                createdAt: cursor.getString(index: 2)!,
                ownerId: cursor.getString(index: 3)!
            )
        }
    )
}
```

### Querying Items (PowerSync.getAll)

The `getAll` method executes a read-only (SELECT) query and returns a set of rows.

```js
// Get all lists
func getLists() async throws {
    try await self.db.getAll(
        sql: "SELECT * FROM \(LISTS_TABLE)",
        parameters: [],
        mapper: { cursor in
            ListContent(
                id: cursor.getString(index: 0)!,
                name: cursor.getString(index: 1)!,
                createdAt: cursor.getString(index: 2)!,
                ownerId: cursor.getString(index: 3)!
            )
        }
    )
}
```

### Watching Queries (PowerSync.watch)

The `watch` method executes a read query whenever a change to a dependent table is made.

```js
// You can watch any SQL query
func watchLists(_ callback: @escaping (_ lists: [ListContent]) -> Void ) async {
    for await lists in self.db.watch(
        sql: "SELECT * FROM \(LISTS_TABLE)",
        parameters: [],
        mapper: { cursor in
            ListContent(
                id: cursor.getString(index: 0)!,
                name: cursor.getString(index: 1)!,
                createdAt: cursor.getString(index: 2)!,
                ownerId: cursor.getString(index: 3)!
            )
        }
    ) {
        callback(lists as! [ListContent])
    }
}
```

### Mutations (PowerSync.execute)

The `execute` method executes a write query (INSERT, UPDATE, DELETE) and returns the results (if any).

```js
func insertTodo(_ todo: NewTodo, _ listId: String) async throws {
    try await db.execute(
        sql: "INSERT INTO \(TODOS_TABLE) (id, created_at, created_by, description, list_id, completed) VALUES (uuid(), datetime(), ?, ?, ?, ?)",
        parameters: [connector.currentUserID, todo.description, listId, todo.isComplete]
    )
}

func updateTodo(_ todo: Todo) async throws {
    try await db.execute(
        sql: "UPDATE \(TODOS_TABLE) SET description = ?, completed = ?, completed_at = datetime(), completed_by = ? WHERE id = ?",
        parameters: [todo.description, todo.isComplete, connector.currentUserID, todo.id]
    )
}

func deleteTodo(id: String) async throws {
    try await db.writeTransaction(callback: SuspendTaskWrapper {
        try await db.execute(
            sql: "DELETE FROM \(TODOS_TABLE) WHERE id = ?",
            parameters: [id]
        )
        return
    })
}
```
