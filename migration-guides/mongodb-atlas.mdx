---
title: "MongoDB Atlas Device Sync Migration Guide"
---

<Info>This guide lays out all the steps of migrating from MongoDB Atlas Device Sync to PowerSync.</Info>

## Introduction

Moving to PowerSync will allow you to benefit from efficient data synchronization using open and proven technologies. Users get always-available, instantly-responsive offline-first apps that also stream data updates in real-time when online.

## Why PowerSync

PowerSync’s history goes as far back as 2009, when the original version of the sync engine was developed as part of an app development platform used by some of the world’s largest industrial companies to provide employees with offline-capable business apps deployed in harsh environments ([learn more](https://www.powersync.com/company) about PowerSync’s history).

PowerSync was spun off as a standalone product in 2023, and gives engineering teams a proven, open and robust sync engine with a familiar **server-client** [architecture](https://docs.powersync.com/architecture/architecture-overview#architecture-overview).

PowerSync’s MongoDB connector has been **developed in collaboration with MongoDB** to provide an easy setup process. It is currently considered [ready for production-use](https://www.powersync.com/blog/powersync-mongodb-connector-module-now-in-beta), provided that you have adequately tested your use cases. It is already being used in production by MongoDB customers.

The server-side [PowerSync Service](https://docs.powersync.com/architecture/powersync-service#powersync-service) connects to MongoDB and pre-processes and pre-indexes data to be efficiently synced to users based on defined “Sync Rules”. Client applications connect to the PowerSync Service to sync data relevant to each user. Incremental updates in MongoDB are synced to clients in real-time. Client applications can read and write data to the local client-side database. PowerSync provides for bi-directional syncing so that writes in the local client-side databases are automatically synced back to the source MongoDB database. If users are offline or have patchy connectivity, PowerSync automatically manages network failures and retries.

By introducing PowerSync as a sync engine, you get:
* **Predictable sync behavior** that syncs relevant data to each user.
* **Data consistency guarantees** that ensure clients always have a consistent local database.
* **Real-time multi-user applications** as data updates are streamed to connected clients in real-time.
* **Instantly responsive user experience**  as the user interaction with the app is unaffected by the network.
* **Offline-first capabilities** enabling apps to continue to work regardless of network conditions.

Please review this guide to understand the required changes and prerequisites. Following the provided steps will help your team transition smoothly.

If you need further assistance at any point, you can:
* [Set up a call](https://calendly.com/powersync/powersync-chat) with PowerSync engineers.
* Ask us anything on our [Discord server](https://discord.gg/powersync).
* [Contact us](hello@powersync.com) through email.

## Architecture: Before and After
If you have MongoDB Atlas Device Sync deployed today, at a high level your architecture will look something like this:

<img src="/images/migration-guides/mongodb-before.png" />

Migrating to PowerSync results in this architecture: (new components in green)

<img src="/images/migration-guides/mongodb-after.png" />

Here is a quick overview of the resulting PowerSync architecture:
* **PowerSync Service**: is available as a cloud-hosted service (PowerSync Cloud), or you can self-host using our Open Edition.
* **Authentication**: PowerSync piggybacks off your app’s existing authentication, and JWTs are used to authenticate between clients and the PowerSync Service. If you are using Atlas Device SDKs for authentication, you will need to implement an authentication provider.
* **PowerSync Client SDKs** use **SQLite** under the hood. Even though MongoDB is a “NoSQL” document database, PowerSync’s use of SQLite works well with MongoDB, since the PowerSync protocol is schemaless (it syncs schemaless JSON data) and we dynamically apply a client-side schema to the data in SQLite using SQLite views. Client-side queries can be written in SQL or you can make use of an ORM (we provide a few integrations)
* **Reads vs Writes**: PowerSync handles syncing of reads differently from writes.
   * **Reads**: The PowerSync Service connects to your MongoDB database and replicates data in real-time to PowerSync clients. Reads are configured using PowerSync’s “Sync Rules”. Sync Rules are more flexible than MongoDB Realm Flexible Sync, but are defined on the server-side, not on the client-side.
   * **Writes**: The client-side application can perform writes directly on the local SQLite database. The writes are also automatically placed into an upload queue by the PowerSync Client SDK. The SDK then uses a developer-defined uploadData() function to manage the uploading of those writes sequentially to the backend. 
* **Authorization**: Authorization is controlled separately for reads vs. writes.
   * **Reads**: The Sync Rules control authorization for which users can access which data.
   * **Writes**: The backend controls authorization for which users can modify which data.
* **Backend**: PowerSync requires a backend API interface to upload writes to MongoDB. There are currently two options:
   * **Custom self-hosted backend**: If you already have a backend application as part of your stack, you should use your existing backend. If you don’t yet have one: We have Node.js, Django and Rails example implementations available.
   * **CloudCode hosted/managed backend**: An alternative option is to use CloudCode, a serverless cloud functions environment provided by PowerSync. We have a template available that you can use as a turnkey starting point.

## Migration Steps

Follow the steps below to migrate a MongoDB Atlas Device Sync app to PowerSync. 

### 1. Remove Realm

Before adding PowerSync, remove MongoDB Realm from your project. This includes uninstalling the Realm SDK and deleting all Realm-related code and dependencies. It is also possible to initially run Realm and PowerSync in parallel, and remove Realm later.

### 2. Create PowerSync account and instance

To get started quickly with PowerSync, sign up for a free PowerSync Cloud account [here](https://accounts.journeyapps.com/portal/powersync-signup?s=mongodb-migration-guide). 

It is also possible to self-host PowerSync. An end-to-end demo app using Docker Compose is available [here](https://github.com/powersync-ja/self-host-demo/tree/main/demos/nodejs-mongodb).

### 3. Connect PowerSync to MongoDB

Once your account is set up, [create a new PowerSync instance](https://docs.powersync.com/installation/database-connection#create-a-powersync-cloud-instance) and configure the instance to connect to your source [MongoDB database](https://docs.powersync.com/installation/database-connection#mongodb-beta-specifics). 

### 4. Define Sync rules

Sync Rules allow you to control which data gets synced to which users/devices. Each PowerSync Service instance has a Sync Rules definition that consists of SQL-like queries in a YAML file.

To get a good understanding of how Sync Rules operate, have a look at our blog post: [Sync Rules from First Principles: Partial Replication to SQLite](https://www.powersync.com/blog/sync-rules-from-first-principles-partial-replication-to-sqlite).

If you have a PowerSync Service instance set up and connected, open the sync-rules.yaml file associated with your PowerSync project and edit the SQL-like queries based on your database schema. Below is a Sync Rules example using a simple database schema. An even simpler starting point would be to have only one or two [Global Data](https://docs.powersync.com/usage/sync-rules/example-global-data) queries.

<Info>Note that MongoDB uses “_id” as the name of the ID field in collections whereas PowerSync uses “id” in its client-side database. This is why `SELECT _id as id` should always be used in the data queries when pairing PowerSync with MongoDB.</Info>

```yaml
# You must start with bucket_definitions
bucket_definitions:    

   # This is the name of the bucket, in this case the global bucket synced to all users.
   global:                                   
      # This is the query used to determine the data in each bucket
      data:                                  
      # Note that we select the MongoDB _id field as id
      - SELECT _id as id, * FROM lists       

   # This is our partition that syncs todos that belong to the singed in user
   user_todos:                               
      # (optional) This query is used to determine which buckets are synced
      parameters: SELECT request.user_id() AS id 
      data: 
      - SELECT _id as id, * FROM todos WHERE owner_id = bucket.id
```

For more information on Sync Rules please visit [this page](https://docs.powersync.com/usage/sync-rules#sync-rules) from the PowerSync docs.

### 5. Add PowerSync to your app

Add PowerSync to your app project by following the instructions for the relevant PowerSync Client SDK.

* Visit our [Client SDK directory](https://docs.powersync.com/client-sdk-references/introduction) for instructions specific to your platform.

### 6. Define your client-side schema

The PowerSync client-side schema represents a “view” of the data synced from the PowerSync Service to the client app. No migrations are required — the schema is applied directly when the local PowerSync SQLite database is constructed.

To make this step easy for you, The PowerSync Dashboard allows automatically generating the client-side schema based on the Sync Rules defined for a PowerSync instance. To generate the schema, go to the [PowerSync Dashboard](https://docs.powersync.com/usage/tools/powersync-dashboard), right-click on the instance, and select “Generate Client Schema”. Alternatively you can use the PowerSync [CLI](https://docs.powersync.com/usage/tools/cli) to generate the schema. 

Here is an example of a client-side schema for PowerSync using a simple `todos` table:

<CodeGroup>

   ```typescript TypeScript - React Native 
   import { column, Schema, Table } from '@powersync/react-native';

   const todos = new Table(
      {
         list_id: column.text,
         created_at: column.text,
         completed_at: column.text,
         description: column.text,
         created_by: column.text,
         completed_by: column.text,
         completed: column.integer
      }, 
      { indexes: { list: ['list_id'] } }
   );

   export const AppSchema = new Schema({
      todos,
      lists
   });
   ```   

   ```typescript TypeScript - Web
   import { column, Schema, Table } from '@powersync/web';

   const todos = new Table(
      {
         list_id: column.text,
         created_at: column.text,
         completed_at: column.text,
         description: column.text,
         created_by: column.text,
         completed_by: column.text,
         completed: column.integer
      },
      { indexes: { list: ['list_id'] } }
   );

   export const AppSchema = new Schema({
      todos
   });
   ```

   ```java Kotlin
   import com.powersync.db.schema.Column
   import com.powersync.db.schema.Index
   import com.powersync.db.schema.IndexedColumn
   import com.powersync.db.schema.Schema
   import com.powersync.db.schema.Table


   val AppSchema: Schema = Schema(
      listOf(
         Table(
               name = "todos",
               columns = listOf(
                  Column.text('list_id'),
                  Column.text('created_at'),
                  Column.text('completed_at'),
                  Column.text('description'),
                  Column.integer('completed'),
                  Column.text('created_by'),
                  Column.text('completed_by')
               ),
               // Index to allow efficient lookup within a list
               indexes = listOf(
                  Index("list", listOf(IndexedColumn.descending("list_id")))
               )
         )
      )
   )
   ```

   ```swift Swift
   import PowerSync

   let todos = Table(
      name: ”todos”,
      columns: [
         Column.text("list_id"),
         Column.text("description"),
         Column.integer("completed"),
         Column.text("created_at"),
         Column.text("completed_at"),
         Column.text("created_by"),
         Column.text("completed_by")
      ],
      indexes: [
         Index(
               name: "list_id",
               columns: [IndexedColumn.ascending("list_id")]
         )
      ]
   )

   let AppSchema = Schema(lists, todos)
   ```

   ```dart Flutter 
   import 'package:powersync/powersync.dart';

   const schema = Schema(([
      Table('todos', [
         Column.text('list_id'),
         Column.text('created_at'),
         Column.text('completed_at'),
         Column.text('description'),
         Column.integer('completed'),
         Column.text('created_by'),
         Column.text('completed_by'),
      ], indexes: [
         Index('list', [IndexedColumn('list_id')])
      ])
   ]));

   ```

</CodeGroup>

There are a few conventions regarding the PowerSync client-side schema to note:

* The schema will exclude the “id” column as the SDK automatically creates an “id” column of type “text”. 
* SQLite has very simple data types and PowerSync uses the exact same [types](https://docs.powersync.com/usage/sync-rules/types#types) as SQLite.
* For MongoDB specific data types, please see the [MongoDB Type Mapping page](https://docs.powersync.com/usage/sync-rules/types#mongodb-beta-type-mapping) in our docs.
* PowerSync also supports [syncing attachments or files](https://docs.powersync.com/usage/use-case-examples/attachments-files#attachments-files). We’ve created helper packages that can be used for attachments/files.


### 7. Instantiate PowerSync database

Now that we have our Sync Rules and client-side schema defined, you can instantiate your PowerSync database on the client-side. This will allow your app to start syncing data with PowerSync.

<CodeGroup>

   ```typescript TypeScript - React Native 
   import { PowerSyncDatabase } from '@powersync/react-native';
   import { Connector } from './Connector';
   import { AppSchema } from './Schema';

   export const db = new PowerSyncDatabase({
      schema: AppSchema,
      database: {
         dbFilename: 'powersync.db'
      }
   });

   export const setupPowerSync = async () => {
      const connector = new Connector();
      db.connect(connector);
   };
   ```   

   ```typescript TypeScript - Web
   import { PowerSyncDatabase } from '@powersync/web';
   import { Connector } from './Connector';
   import { AppSchema } from './Schema';

   export const db = new PowerSyncDatabase({
      schema: AppSchema,
      database: {
         dbFilename: 'powersync.db'
      }
   });

   export const setupPowerSync = async () => {
      const connector = new Connector();
      db.connect(connector);
   };
   ```

   ```java Kotlin
   // 1: Create platform specific DatabaseDriverFactory to be used by the PowerSyncBuilder to create the SQLite database driver.

   // commonMain
   import com.powersync.DatabaseDriverFactory
   import com.powersync.PowerSyncDatabase

   // Android
   val driverFactory = DatabaseDriverFactory(this)
   // iOS & Desktop
   val driverFactory = DatabaseDriverFactory()

   // 2: Build a PowerSyncDatabase instance using the PowerSyncBuilder and the DatabaseDriverFactory. The schema you created in a previous step is provided as a parameter:

   // commonMain
   // Uses the backend connector that will be created in the next step
   database.connect(MyConnector())


   // 3: Connect the PowerSyncDatabase to the backend connector:

   // commonMain
   // Uses the backend connector that will be created in the next step
   database.connect(MyConnector())

   ```

   ```swift Swift
   let schema = AppSchema
   let connector = Connector();

   let db = PowerSyncDatabase(
      schema: schema,
      dbFilename: "powersync.sqlite"
   )

   await db.connect(connector: connector);
   ```

   ```dart Flutter 
   import 'package:powersync/powersync.dart';
   import 'package:path_provider/path_provider.dart';
   import 'package:path/path.dart';

   openDatabase() async {
      final dir = await getApplicationSupportDirectory();
      final path = join(dir.path, 'powersync-dart.db');

      db = PowerSyncDatabase(schema: schema, path: path);
      await db.initialize();
   }
   ```

</CodeGroup>

### 8. Reading and writing data

Reading data in the application which uses PowerSync is very simple: we use SQLite syntax to query data in our local database. The same applies to writing data, insert statements are used to write new rows into tables.

<CodeGroup>

   ```typescript TypeScript - React Native & Web
   // Reading Data
   export const getTodos = async () => {
      const results = await db.getAll('SELECT * FROM todos');
      return results;
   }

   // Writing Data
   export const insertTodo = async (listId: string, description: string) => {
      await db.execute('INSERT INTO todos (id, created_at, list_id, description) VALUES (uuid(), date(), ?, ?)', [listId, description]);
   }
   ```   

   ```java Kotlin
   // Reading Data
   export const getTodos = async () => {
      const results = await db.getAll('SELECT * FROM todos');
      return results;
   }

   // Writing Data
   suspend fun insertTodo(listId: String, description: String) {
      database.writeTransaction {
         database.execute(
               sql = "INSERT INTO todos (id, created_at, list_id, description) VALUES (uuid(), date(), ?, ?)",
               parameters = listOf(listId, description)
         )
      }
   }
   ```

   ```swift Swift
   // Reading Data
   func getTodos() async throws {
      try await self.db.getAll(
         sql: "SELECT * FROM todos",
         mapper: { cursor in
               TodoContent(
                  list_id: cursor.getString(index: 0)!,
                  description: cursor.getString(index: 1)!,
                  completed: cursor.getString(index: 2)!,
                  created_by: cursor.getString(index: 3)!,
                  completed_by: cursor.getString(index: 4)!,
                  completed_at: cursor.getString(index: 5)!
               )
         }
      )
   }

   // Writing Data
   func insertTodo(_ listId: String, _ description: String) async throws {
      try await db.execute(
         sql: "INSERT INTO todos (id, created_at, list_id, description) VALUES (uuid(), date(), ?, ?)",
         parameters: [listId, description]
      )
   }
   ```

   ```dart Flutter 
   /// Reading Data
   Future<TodoList> getTodos() async {
      final result = await db.get('SELECT * FROM todos');
      return TodoList.fromRow(result);
   }

   /// Writing Data
   await db.execute(
      'INSERT INTO todos (id, created_at, list_id, description) VALUES (uuid(), date(), ?, ?)',
      ['ID', 'Description'],
   );
   ```

</CodeGroup>

<Info>The best way to ensure there’s referential integrity in your database is to use UUIDs when inserting new rows on the client side. UUIDs can help solve sync issues when working with offline/local capable applications, allowing for unique identification of records created on the client before they are synced to the server.</Info>

### 9. Accept incoming uploads

While MongoDB Atlas Device Sync provides turnkey writes/uploads to the backend MongoDB database, PowerSync offers control over how writes are applied. There are two options:

* **CloudCode hosted/managed backend**: PowerSync offers a turnkey solution hosted on the same infrastructure as PowerSync Cloud.
* **Custom self-hosted backend**: Alternatively, writes can be processed through your own backend, allowing you to apply your own business logic, validations, authorization and conflict resolution logic.

#### Using PowerSync’s turnkey backend functionality

PowerSync provides serverless cloud functions for backend functionality, with a template available for MongoDB. See the [step-by-step instructions](https://docs.powersync.com/usage/tools/cloudcode) on how to use the template. If you plan on using this option, please [get in touch with us](https://www.powersync.com/contact) so we can get you set up.

The template can be customized, or it can be used as-is. CloudCode is provided as a fully-managed service running on the same cloud infrastructure as the rest of PowerSync Cloud.

The template provides [turnkey conflict resolution](https://www.powersync.com/blog/turnkey-backend-functionality-conflict-resolution-for-powersync#turnkey-conflict-resolution) which roughly matches what is provided by Atlas Device Sync.

For more information on this, see our blog post: [Turnkey Backend Functionality & Conflict Resolution for PowerSync](https://www.powersync.com/blog/turnkey-backend-functionality-conflict-resolution-for-powersync).


#### Using  your own backend API

This option gives you complete control over how incoming writes are applied to your MongoDB backend database. The simplest backend implementation is to simply apply writes to MongoDB as they are received, which results in a last-write-wins conflict resolution strategy (same as the “turnkey backend functionality” option above).

On the client-side, you need to write up the `uploadData()` function in the “backend connector” to use your own backend API. The [App Backend Setup](https://docs.powersync.com/installation/app-backend-setup) section of our docs provides step-by-step instructions for this. 

Also see the section on [how to set up a simple backend API](https://www.powersync.com/blog/migrating-a-mongodb-atlas-device-sync-app-to-powersync#backend-api-setup) in our practical MongoDB migration [example](https://www.powersync.com/blog/migrating-a-mongodb-atlas-device-sync-app-to-powersync) on our blog.

## Questions? Need help?

[Get in touch](https://www.powersync.com/contact) with us.